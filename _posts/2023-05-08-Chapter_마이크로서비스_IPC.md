---
title:  "IPC & CQRS"
excerpt: "DevOps 부트캠프 Section 3 "

categories:
  - Blog
tags:
  - [Blog, DevOps]

toc: true
toc_sticky: true
 
date: 2023-05-08
last_modified_at: 2023-05-08
---
# IPC
IPC는 Inter-Process Communication의 약자로, 프로세스 간의 통신을 의미한다. <br>
마이크로서비스 아키텍처에서는 각각의 마이크로서비스가 독립적인 프로세스로 실행되기 때문에, 마이크로서비스 간에도 IPC를 통해 통신이 이루어진다. <br>
이를 통해 각각의 마이크로서비스는 독립적으로 실행될 수 있으며, 분리된 데이터베이스와 통신하여 동작할 수 있다.<br> 
IPC 방법으로는 REST API, gRPC, Kafka 등이 있습니다.

<br><br> 

## HTTP의 동기적 응답
HTTP 프로토콜은 기본적으로 동기적인 메커니즘으로 분류된다. <br>
클라이언트가 서버에 요청을 보내면 서버는 해당 요청에 대한 즉각적인 응답을 보내야한다. <br>
만약 서버가 제때 응답을 보내지 못하면 클라이언트는 오랫동안 응답을 기다리는 blocking 상태가 될 수 있다.<br>
따라서 HTTP는 요청과 응답이 쌍을 이루어야 하고, 이는 동기적인 메커니즘이라고 볼 수 있다.


## HTTP의 1대1 응답
HTTP는 일대일 통신 프로토콜이다. <br>
요청/응답으로 이루어진 한 번의 트랜잭션에서 서버는 여러 클라이언트에게 동시에 응답을 전달하지 않는다. <br>
서버는 여러 클라이언트를 상대할 수 있지만, 그것은 여러 번의 1:1 커뮤니케이션이며, 동시에 여러 클라이언트를 상대하는 1대다 커뮤니케이션이 아니다.

<br><br>

# JSON
- JavaScript Object Notation라는 의미의 축약어로 데이터를 저장하거나 전송할 때 많이 사용되는 경량의 DATA 교환 형식
- Javascript에서 객체를 만들 때 사용하는 표현식을 의미한다.
- JSON 표현식은 사람과 기계 모두 이해하기 쉬우며 용량이 작아서, 최근에는 JSON이 XML을 대체해서 데이터 전송 등에 많이 사용한다.
- JSON은 데이터 포맷일 뿐이며 어떠한 통신 방법도, 프로그래밍 문법도 아닌 단순히 데이터를 표시하는 표현 방법일 뿐이다.

## 특징
- 서버와 클라이언트 간의 교류에서 일반적으로 많이 사용된다.
- 자바스크립트 객체 표기법과 아주 유사하다.
- 자바스크립트를 이용하여 JSON 형식의 문서를 쉽게 자바스크립트 객체로 변환할 수 있는 이점이 있다.
- JSON 문서 형식은 자바스크립트 객체의 형식을 기반으로 만들어졌다.
- 자바스크립트의 문법과 굉장히 유사하지만 텍스트 형식일 뿐이다.
- 다른 프로그래밍 언어를 이용해서도 쉽게 만들 수 있다.
- 특정 언어에 종속되지 않으며, 대부분의 프로그래밍 언어에서 JSON 포맷의 데이터를 핸들링 할 수 있는 라이브러리를 제공한다.


## XML vs JSON
XML
- 데이터 값 양쪽으로 태그가 있다.<br>
(HTML을 근본으로 했기에 태그라는 것이 없을 수가 없는데, 그 태그를 줄인다 해도 최소한 표현하려면 양쪽에 몇글자씩이 있어야 한다.)

JSON
- 태그로 표현하기 보다는 중괄호({}) 같은 형식으로 하고, 값을 ','로 나열하기에 그 표현이 간단하다.

JSON과 XML은 모두 데이터 교환을 위한 포맷이지만, JSON이 XML보다 더욱 유리한 점이 있다.

가독성
- JSON은 더욱 간결하고 가독성이 좋다. 
- XML은 태그 형태로 불필요한 공백이 포함되어 있어 가독성이 떨어질 수 있다.

처리 속도
- JSON은 XML에 비해 처리 속도가 빠르다. 
- JSON은 JavaScript에서 기본적으로 지원되는 형식이기 때문에 파싱 속도가 빠르고, 대용량 데이터 처리에도 더욱 효율적이다.

크기
- JSON은 XML보다 더욱 작은 크기로 데이터를 전송할 수 있다. 
- JSON은 불필요한 태그가 없기 때문에 데이터 크기를 줄일 수 있다.

자바스크립트와의 호환성
- JSON은 자바스크립트에서 기본적으로 지원되는 형식이기 때문에 자바스크립트와의 호환성이 더욱 높다. 
- 이를 통해, 서버와 클라이언트 간 데이터 교환을 더욱 쉽게 할 수 있다.

이러한 이유들로 인해, JSON이 XML에 비해 더욱 우수한 데이터 교환 포맷으로 평가받고 있다.


## JSON 문법
- JSON 형식은 자바스크립트 객체와 마찬가지로 key / value가 존재할 수 있으며 key값이나 문자열은 항상 쌍따옴표를 이용하여 표기해야한다.
- 객체, 배열 등의 표기를 사용할 수 있다.
- 일반 자바스크립트의 객체처럼 원하는 만큼 중첩시켜서 사용할 수도 있다.
- JSON형식에서는 null, number, string, array, object, boolean을 사용할 수 있다.


## JSON 형식
1. name-value형식의 쌍
- 여러가지 언어들에서 object등으로 실현되었다.
- { String key : String value }

2. 값들의 순서화된 리스트 형식
- 여러가지 언어들에서 배열(Array) 등으로 실현되었다.
- [value1, value2, ...]


## JSON의 문제점
AJAX 는 단순히 데이터만이 아니라 JavaScript 그 자체도 전달할 수 있다. <br>
이 말은 JSON데이터라고 해서 받았는데 단순 데이터가 아니라 JavaScript가 될 수도 있고, 그게 실행 될 수 있다는 것이다. (데이터인 줄 알고 받았는데 악성 스크립트가 될 수 있다.)

위와 같은 이유로 받은 내용에서 순수하게 데이터만 추출하기 위한 JSON 관련 라이브러리를 따로 사용하기도 한다.



## JSON 메서드
- JSON.stringify : Object type을 JSON으로 변환한다.
- JSON.parse : JSON을 Object type으로 변환한다.

stringify하는 과정을 직렬화(serialize)한다고 한다.<br>
JSON.parse를 적용하는 과정을 역직렬화(deserialize)한다고 한다.

|제목|자바스크립트 객체|JSON|
|------|---|---|
|키|키는 따옴표 없이 쓸 수 있음|반드시 큰따옴표를 붙여야 함|
|문자열 값|문자열 값은 어떠한 형태의 따옴표도 사용 가능|반드시 큰따옴표로 감싸야함|



## 텍스트 교환 형식? 이진 교환 형식?
텍스트 형식과 이진 형식의 데이터 교환 포맷의 주요 차이점은 데이터를 표현하는 방식이다. <br>
텍스트 형식의 데이터는 사람이 읽을 수 있는 문자열로 표현되며, 이진 형식의 데이터는 컴퓨터가 직접 이해할 수 있는 이진 데이터로 표현된다.

텍스트 형식의 데이터 교환 포맷의 장점은 다음과 같다.

- 사람이 읽을 수 있어서 디버깅과 테스트에 용이하다.
- 텍스트 파일을 기반으로 하기 때문에, 텍스트 에디터에서 직접 수정할 수 있어서 편리하다.
- 여러 언어와 플랫폼에서 지원된다.

반면 이진 형식의 데이터 교환 포맷의 장점은 다음과 같습니다.

- 텍스트 형식보다 더 작은 파일 크기를 가지므로, 대량의 데이터를 전송할 때 더 효율적이다.
- 직렬화(deserialization)과 역직렬화(serialization)가 더 빠르므로, 처리 시간이 더 짧다.
- 데이터의 정확한 포맷을 미리 정의할 수 있으므로, 데이터 교환 시 오류 발생 가능성이 적다.

따라서, 텍스트 형식의 데이터 교환 포맷은 가독성과 편리성을 중시할 때 사용되고, 이진 형식의 데이터 교환 포맷은 대량의 데이터 전송과 처리 시간 단축을 중시할 때 사용된다.

<br><br><br>

# 동기식 요청/응답 통신 REST
REST (Representational State Transfer)는 HTTP 프로토콜을 기반으로 한 웹 서비스 아키텍처이다.<br> RESTful 서비스는 자원을 URI(Uniform Resource Identifier)로 표현하고, HTTP Method(GET, POST, PUT, DELETE 등)을 사용하여 자원을 조작한다.

동기식 요청/응답 통신이란 클라이언트가 요청을 보내고, 서버가 그 요청에 대한 응답을 보내기까지 클라이언트가 대기하는 방식을 의미한다. <br>
REST에서도 요청과 응답은 동기적으로 이루어진다.<br> 클라이언트가 요청을 보내면 서버는 요청에 대한 응답을 보내기 전까지 클라이언트가 대기하게 된다. <br>
이후 서버는 클라이언트에게 응답을 보내고, 클라이언트는 응답을 받은 후에 다음 동작을 수행한다.

동기식 요청/응답 통신의 장점은 간단하며, 요청과 응답이 동기적으로 이루어지므로 어떤 요청에 대한 응답이 어떤 요청에 대한 것인지 쉽게 확인할 수 있다. <br>
단점은 클라이언트가 응답을 받을 때까지 대기해야 하므로, 대용량 데이터를 처리할 때는 시간이 오래 걸릴 수 있다. <br>
또한, 여러 개의 요청을 동시에 처리하는 경우에는 성능 문제가 발생할 수 있다.

기존 포스팅 중에 REST에 대해 좀 더 자세하게 쓴 포스팅이 있다.

https://wngud9646.github.io/chapter-http-api-%EB%94%94%EC%9E%90%EC%9D%B8

<br><br><br>

# 메시지 브로커를 이용한 비동기식 통신
## 메세지 브로커
송신자의 메시지 프로토콜 형식으로부터의 메시지를 수신자의 메시지 프로토콜 형식으로 변환하는 중간 컴퓨터 프로그램 모듈

메시지 브로커들은 응용 소프트웨어가 이전에 정의해둔 메지시를 교환할 수 있는 전기통신의 요소 또는 컴퓨터 네트워크이다.


## 메세지 브로커의 필요성
분산 애플리케이션에서 프로세스 간의 느스한 결합을 제공하는 것이 가장 큰 장점이다.<br>
만약, 강하게 결합된 시스템에서 장애가 발생한다면 어덯게 될까?

예를 들어 다음과 같은 사진에서 서버2에 장애가 발생하면 서버1에서 서버2로 가는 데이터유실이 발생하게 된다.
![alt text](/images/tightcoupled.png) 

이때 메시지 브로커가 중간단계 역할을 하여 장애가 발생하더라도 메시지 브로커에 보관을 해놓기 때문에 데이터가 유실되지 않는다.
![alt text](/images/looselycoupled.png) 

<br><br>

## 메세지 브로커의 특징
용어<br>
생산자: 메시지를 보내는 사람
소비자: 메시지를 받는 사람
발행: 메시지를 보내는 것
소비: 메시지를 받는 것

특징
- 프로그램간의 직접 연결 없음:less dependency, fault tolerant
  - 소비자 프로세스가 죽어있어도 생산자는 메시지를 보낼 수 있음
  - 생산자 프로세스가 죽어있어도 소비자는 메시지를 수신할 수 있음
- 메시지 브로커에 있는 메시지는 소비자(수신자)가 꺼낼 때까지 안전하게 보관됨: durability
  - (프로세스가 죽어 있어도)메시지는 소비하기 전까지는 사라지지 않음
  - 따라서, 프로그램 간 통신은 시간과 독립적.
- 통신이 이벤트에 의해 구동될 수 있음
  - 큐의 상태에 따라 프로그램을 제어할 수 있다.<br>
  (예를 들어 메시지가 큐에 도착하는 즉시 프로그램이 시작되도록 설정할 수 있다.)
- 확장에 용이함
  - 메시지 브로커는 여러 큐를 만들거나, 수평적으로 확장하여 메시지 부하 증가를 처리할 수 있다.


## 메시지 브로커 툴
대표적인 메시지 브로커 세가지에 대해 알아보자.

- Apache Kafka
- Amazon SQS
- Amazon Kinesis


### Apache Kafaka
Apache Kafaka는 고성능 데이터 파이프라인, 스트리밍 분석, 데이터 통합 및 미션 크리티컬 애플리케이션에 수천 개의 회사가 사용하는 오픈 소스 분산 이벤트 스트리밍 플랫폼이다.


#### 핵심기능
- 높은 처리량: 대기시간이 2ms 미만인 머신 클러스터를 사용하여 제한된 네트워크 처리량으로 메시지를 전달한다.
- 확장성
- 영구 저장소
- 고가용성

#### 사용 이유
- 실시간 트랜잭션(OLTP) 처리와 비동기 처리가 동시에 이루어 지지만 통합된 전송 영역의 부재로 복잡도가 증가
- 파이프라인 관리가 어려움.

![alt text](/images/kafka.png) 

그래서 카프카가 발신자와 수신자를 연결해준다.

- 발신자(Publish): 카프카에게 데이터를 전송하기만 하면 된다.
- 수신자(Subscribe): 수신자는 카프카에 원하는 토픽을 구독한다.

<br><br>

### Aws SQS
AWS SQS는 마이크로서비스, 분산시스템 및 서버리스 애플리케이션을 쉽게 분리하고 확장할 수 있도록 지원하는 완전관리형 메시지 대기열 서비스이다.

장점
- 관리 오버헤드 제거<br>
AWS는 가용성과 확장성이 뛰어나고 선 결제 비용이 없어 설치 및 구성하는 시간과 비용을 절약할 수 있다. 그래서 신속하고 효율적인 구축 및 확장을 할 수 있다.

- 안정적인 메시지 전달<br>
SQS를 사용하면 애플리케이션 구성요소를 분리할 수 있어서 구성요소가 독립적으로 실행되고 시스템의 전체 내결함성이 향상된다.

- 보안<br>
SQS에서는 서버측 암호화를 통해 각 메시지 본문을 암호화하여 민감한 데이터를 교환 할 수 있다.

- 탄력적, 비용 효율적인 확장<br>
AWS를 활용하여 필요에 따라 동적으로 확장된다.그리고 사용할 수 있는 대기열당 메시지 수에 제한이 없으며 표준 대기열은 거의 무제한의 처리량을 제공한다.

<br><br>

### AWS Kinesis
AWS Kinesis Data Streams는 모든 규모의 데이터 스트림을 쉽게 캡쳐, 처리 및 저장할 수 있는 서버리스 스트리밍 데이터 서비스이다.

특징
- 서비스형
- pull방식 및 push 방식 둘다 사용가능
- 스트림 데이터와 같은 빅데이터를 다루는 데 더욱 유리
- 데이터 소비 행위 자체를 replay할 수 있음
- 데이터를 바로 삭제하지 않고 며칠 후에 만료 되도록 설정할 수 있음
- 처리량에 대한 프로비저닝 필요



## Queue 방식과 Topic 방식
### Queue 방식
Queue 방식은 메시지를 큐(Queue)에 쌓아두고, 그 큐에 있는 메시지를 하나씩 처리하는 방식이다. <br>
이 방식에서는 메시지를 받은 시간 순서대로 처리가 되기 때문에, FIFO(First-In-First-Out) 방식이라고도 불린다. <br>
큐에는 메시지를 보내는 프로듀서와 메시지를 받아 처리하는 컨슈머가 존재하며, 프로듀서가 메시지를 큐에 보내면, 컨슈머는 그 메시지를 큐에서 꺼내서 처리한다. <br>
이때 컨슈머가 메시지를 처리할 때, 해당 메시지는 큐에서 삭제된다.

Queue 방식은 일반적으로 비동기식 방식으로 동작한다. <br>
즉, 프로듀서가 메시지를 보낸 후, 컨슈머가 그 메시지를 처리하기 전에는 다른 일을 할 수 있다.<br> 이런 특징 덕분에 Queue 방식은 많은 양의 데이터를 처리해야 할 때, 빠르고 안정적으로 처리할 수 있다.<br> 
대표적으로 RabbitMQ와 같은 메시지 브로커에서 Queue 방식을 지원합니다.


### Topic 방식
Topic 방식은 Publisher가 메시지를 발행(Publish)할 때, 메시지의 구독(Subscription) 대상을 토픽(Topic)으로 지정한다. <br>
이 때, 하나의 토픽에 여러 개의 구독자(Subscriber)가 존재할 수 있다.

메시지를 발행하는 Publisher는 메시지가 어느 토픽으로 전달될지만 지정하고, 실제로 메시지를 받는 Subscriber는 자신이 관심 있는 토픽만 구독할 수 있다. <br>
이렇게 구독자는 자신이 관심 있는 토픽을 구독하면서 해당 토픽으로 발행된 메시지들을 수신할 수 있다.

Topic 방식은 Pub/Sub 모델에서 주로 사용되며, 이벤트 기반 아키텍처에서 많이 활용된다. <br>
예를 들어, 특정 이벤트가 발생했을 때 해당 이벤트를 처리해야 하는 서비스들은 해당 이벤트를 구독하고, 이벤트가 발생했을 때 메시지 브로커로부터 해당 이벤트를 수신하여 처리하게 된다. <br>
이렇게 함으로써 이벤트들 간의 결합도를 낮출 수 있어 시스템 유연성과 확장성을 높일 수 있습니다.

<br><br>

## Queue 방식과 Topic 방식의 차이
### 메시지의 발행(Publish)과 구독(Subscribe) 방식
Queue 방식: 메시지는 큐(Queue)라는 버퍼에 저장되어 있으며, 구독자는 해당 큐에서 메시지를 직접 가져온다. <br>
이 방식에서는 발행자(Publisher)와 구독자(Subscriber)가 일대일로 연결된다. <br>
즉, 한 메시지는 하나의 구독자에게만 전달된다.

Topic 방식: 메시지는 토픽(Topic)이라는 주제에 대한 구독자(Subscriber)들에게 브로드캐스트(broadcast)된다.<br> 
발행자는 특정 토픽에 메시지를 발행하면, 해당 토픽을 구독하는 모든 구독자에게 메시지가 전달된다.<br> 
따라서 한 메시지는 여러 구독자에게 전달될 수 있습니다.

### 메시지의 처리 방식
Queue 방식: 큐에 저장된 메시지는 구독자에게 지속적으로 전달된다. <br>
메시지는 한 번에 하나의 구독자에게만 전달되며, 구독자가 메시지를 가져가지 않으면 큐에 계속 쌓인다.

Topic 방식: 토픽을 구독하는 구독자들은 메시지를 바로바로 받지 않을 수 있다. <br>
따라서 메시지를 저장하고 있는 것이 아닌, 메시지를 수신하고 처리하는 책임은 구독자에게 있다. <br>
즉, 구독자가 온라인이 아닐 때는 메시지를 받지 못하며, 온라인이 되면 메시지를 받습니다.

### 메시지의 순서 보장
Queue 방식: 큐(Queue)는 메시지를 순서대로 저장하며, 각 메시지는 고유한 식별자를 가지고 있다.<br> 
따라서 각 구독자는 큐에서 메시지를 가져갈 때 메시지가 발행된 순서대로 가져갈 수 있다.

Topic 방식: 메시지는 구독자들에게 브로드캐스트되기 때문에, 메시지의 순서를 보장하기 어렵다. <br>
따라서 Topic 방식에서는 메시지의 순서를 보장하기 위해 추가적인 작업이 필요할 수 있다.


<br><br><br>

# CQRS
CQRS : Command and Query Responsibility Segregation(명령과 조회의 책임 분리)<br>
즉, CQRS 패턴은 커맨드와 책임을 분리하는 패턴이다.<br>
책임 분리를 위해서는 코드의 모듈이 분리되어야 한다.

<br><br>

## 기존 아키텍처의 데이터 접근 방식의 단점
일반적인 아키텍처에서는 비지니스로직이 데이터액세스 클래스를 호출하여 DB에 접근한다.<br>
하지만 아래와 같은 단점이 발생할 수 있다.<br>

- 데이터의 읽기와 쓰기 표현 사이에 종종 불일치가 발생할 수 있으며, 추가적인 열 또는 속성이 있어서 작업의 필수 부분은 아니지만 정확하게 업데이트되어야 하는 경우가 있다는 것을 나타낸다. <br>
즉, 데이터를 저장하거나 업데이트할 때 필요한 최소한의 데이터만 포함하더라도 응용 프로그램에서는 데이터를 보다 많은 정보와 함께 사용해야 하는 경우가 있으며, 이러한 경우 데이터 표현의 불일치가 발생할 수 있다. <br>
이 경우, 추가적인 열이나 속성을 업데이트할 때도 올바르게 처리해야 한다.

- Data contention(데이터 경합)은 동시에 같은 데이터를 조작하는 작업들이 충돌하여 발생하는 문제이다. <br>
예를 들어, 두 개의 프로세스가 동시에 같은 데이터를 업데이트하려고 할 때, 각각의 프로세스가 데이터를 읽어오고 수정하고 저장하는 과정에서 경합이 일어날 수 있다. <br>
이런 경우에는 두 프로세스가 동시에 데이터를 수정하는 것이 아니라, 하나의 프로세스가 먼저 작업을 완료하고 나서 다음 작업을 수행하도록 해야 한다. <br>
이를 위해 동시성 제어 기법이 사용될 수 있다.

- 이전에 사용되던 전통적인 방식은 데이터 저장소와 데이터 접근 레이어에 부하가 걸리고, 정보를 검색하기 위해 필요한 쿼리의 복잡성 때문에 성능에 부정적인 영향을 미칠 수 있다. <br>
즉, 데이터베이스에 많은 부하가 걸리면서 복잡한 쿼리를 작성해야 하므로 처리 속도가 느려지는 문제가 발생할 수 있다.

- 보안 및 권한 관리가 복잡해질 수 있다는 것을 말하고 있다. <br>
데이터베이스에서 각 엔티티는 읽기 및 쓰기 작업의 대상이므로 잘못된 컨텍스트에서 데이터를 노출할 수 있다. <br>
예를 들어, 사용자가 자신의 개인 정보를 읽을 수 있지만, 다른 사용자의 개인 정보를 읽을 수 없어야 할 경우가 있다. <br>
이 경우 보안 규칙을 구현하는 것이 어렵고 권한 부여가 제대로 이루어지지 않으면 민감한 데이터가 노출될 위험이 있다.


## CQRS 패턴에서의 데이터 접근 구조
CQRS 패턴은 단적으로 Read와 Write를 분리하는 것을 뜻한다. <br>
하지만 그 구현은 구체적으로 어플리케이션까지만 적용할 수도 있고, DB의 모델까지만 분리할 수도 있고, DB 그 자체를 분리하여 적용할 수도 있다.<br>
다만 DB의 모델 이상으로 Read와 Write가 분리된다면, ORM의 스캐폴딩 매커니즘으로 생성되는 SQL문들을 사용할 수 없다.

객체 지향적인 관점에서라면 데이터라는 하나의 객체를 대상으로 읽기/쓰기 등의 행위들이 구현되어야하겠지만, CQRS는 데이터 액세스 클래스를 아래와 같이 설계한다.<br><br>

### CQRS 패턴으로 설계된 아키텍쳐 (하나의 DB 내에 읽기/쓰기 모델 분리)
![alt text](/images/cqrs.png)

- 명령은 데이터 중심이 아니라 작업 기반이어야 한다.
("예약 상태를 예약으로 설정"이 아니라 "호텔 객실 예약").
- 명령은 동기적으로 처리되지 않고 비동기 처리를 위해 큐에 배치될 수 있다.
- 쿼리는 데이터베이스를 수정하지 않습니다. 쿼리는 도메인 지식을 캡슐화하지 않는 DTO를 반환한다.


### 별도의 읽기/쓰기 DB를 사용할 때의 동기화 문제
읽기 DB와 쓰기 DB를 분리할 경우, 동기화 상태 유지에 대한 난관을 겪게 된다.<br>
일반적으로 동기화는 쓰기 DB에서 업데이트가 발생할 경우, 이벤트를 게시하는 이벤트 기반 아키텍쳐 스타일로 구현되어 처리된다. <br>
이 경우, DB 업데이트와 이벤트 게시는 하나의 트랜잭션에서 발생해야 한다.

Read data store는 Write data store의 Read-only replica일 수도 있고, 완전히 다르게 취급되는 하나의 별도 모델일 수 있다.<br>
만약 Read-only Replica를 여러개 사용하면 쿼리 퍼포먼스를 향상시킬 수 있다.

CQRS의 일부 구현은 Event Sourcing Pattern을 사용한다.<br>
하지만 이벤트 소싱은 디자인에 복잡성을 더하게 된다.

[Event Sourcing Pattern](https://docs.microsoft.com/en-us/azure/architecture/patterns/event-sourcing): https://docs.microsoft.com/en-us/azure/architecture/patterns/event-sourcing


## CQRS의 이점 및 고려사항
이점
- Independent Scaling
  - 읽기 모델과 쓰기 모델을 필요에 따라 독립적으로 확장 가능
- Optimized data schemas
  - 읽기 모델은 쿼리에 최적화된 스키마를 사용 가능
- Security
  - 호출되는 도메인 엔티티에 대해 확인하는 로직 구현이 더 쉬움
- Seperation of concerns
  - 보통 복잡한 비지니스 로직 구현은 대부분 쓰기 모델에 속하며, 읽기 모델은 간단하게 구현된다. 그에 따라 읽기와 쓰기를 분리하면 유지관리가 더 쉽고 유연한 모델이 구현될 수 있다.
- Simpler queries
  - DB에 논리적인 View가 아닌, Materialized View를 저장함으로써 애플리케이션에서 복잡한 조인이 사용된 쿼리문을 피할 수 있다.


고려사항
- Complexity
  - CQRS 패턴의 아이디어는 간단하나, 해당 아이디어가 이벤트 소싱 패턴까지 이어질 경우 구현이 매우 어렵다.
- Messaging
  - CQRS 패턴에서 메시징이 필요하진 않지만, 메시징을 사용해서 명령을 처리하고 이벤트를 게시하는 것이 일반적이다. (Kafka)
  - 메시징을 사용하는 경우, Application은 메시지 실패 또는 중복 메시지 처리에 대한 로직을 상세하게 구현해야 한다.
- Eventual consistency
  - 읽기 모델과 쓰기 모델이 서로 다른 DB로 분리됐을 경우, 읽기 모델은 쓰기 모델의 변경 사항이 실시간으로 반영되도록 구현해야 한다. <br>
  그리고 만약 유저에게서 과거의 데이터를 기준으로 Request가 발생했을 경우, 처리하는데에 어려움이 발생하게 된다.