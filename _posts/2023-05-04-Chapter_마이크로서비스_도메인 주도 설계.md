---
title:  "마이크로 서비스 아키텍처 & 모놀리틱 아키텍처"
excerpt: "DevOps 부트캠프 Section 3 "

categories:
  - Blog
tags:
  - [Blog, DevOps]

toc: true
toc_sticky: true
 
date: 2023-05-04
last_modified_at: 2023-05-04
---
# 도메인 주도 설계
DDD(Domain-Driven Design) 또는 도메인 주도 설계라고 부른다. 도메인 패턴을 중심에 놓고 설계하는 방식을 일컫는다.

<br>

## 특징
- 도메인 그 자체와 도메인 로직에 초점을 맞춘다. <br>
일반적으로 많이 사용하는 데이터 중심의 접근법을 탈피해서 순수한 도메인의 모델과 로직에 집중하는 것을 말한다.
- 보편적인(ubiquitous) 언어의 사용이다. <br>
도메인 전문가와 소프트웨어 개발자 간의 커뮤니케이션 문제를 없애고 상호가 이해할 수 있고 모든 문서와 코드에 이르기까지 동일한 표현과 단어로 구성된 단일화된 언어체계를 구축해나가는 과정을 말한다.<br> 이로서 분석 작업과 설계 그리고 구현에 이르기까지 통일된 방식으로 커뮤니케이션이 가능해진다.
- 소프트웨어 엔티티와 도메인 컨셉트를 가능한 가장 가까이 일치시키는 것이다. <br>
분석 모델과 설계가 다르고 그것과 코드가 다른 구조가 아니라 도메인 모델부터 코드까지 항상 함께 움직이는 구조의 모델을 지향하는 것이 DDD의 핵심원리이다.


## 데이터 주도 설계
데이터 주도 설계란 객체가 가져야 할 데이터에 초점을 두고 설계를 하는 방식을 일컫는다. <br>
데이터 주도 설계 에서는 객체 자신이 포함하고 있는 데이터를 조작하는 데 필요한 행동을 정의한다.

설계 시 협력에 고민을 하지 않았기 때문에 과도한 접근자와 수정자가 탄생하게 된다. <br>
이는 후에 객체가 어떤 곳에 사용될지 알 수가 없기 때문에 최대한 많은 접근자와 수정자를 만들게 된 것이다.
결과적으로 데이터 중심 설계는 외부에 대부분의 구현이 노출되기 때문에 캡슐화의 원칙을 위반하게 된다.<br>
내부 구현이 퍼블릭 인터페이스에 노출 되며 이 때문에 다른 객체들과 강하게 결합되게 된다. <br>
이로 인해 객체의 내부 구현이 변경될 때 이 인터페이스에 의존하는 모든 객체들이 함께 변경되므로 높은 결합도를 유지하게 된다

<br><br>

## 도메인 주도 설계의 필요성
- 도메인 모델의 적용 범위를 구현까지 확장하여 도메인 지식을 구현 코드에 반영
- 공통의 언어(유비쿼터스 언어)를 사용하여 도메인과 구현을 충분히 만족하는 모델을 만든다.
- 실제 코드로 구현 가능한 현실성 있는 도메인 모델 분석과 그것을 추상화하는 설계
- "설계를 하라, 그 다음에 구축하라"가 아니다.

<br><br>

## MSA와 도메인 주도 설계
Cloud 환경도 Container가 대세가 되었고, 그렇기 때문에 마이크로서비스가 더 중요해졌다.<br>
기존에는 Hypervisor기반의 모놀리식 아키텍쳐였다면, 지금은 Domain Service를 중심으로 Containter를 Scale In / Out 하는 Ops환경이 대세가 되었기 때문에 도메인 주도 설계와 MSA는 밀접한 연관이 있다.

두 방식 모두 서비스들을 쪼개고 쪼개서 시장의 빠른 변화에 민첩하게 대응하기 위함이다.<br>
물론 시장의 변화도 빠르게 반영하는 것도 중요하지만, 지금은 DevOps의 시대이기 때문에인것도 가장 큰 요소이다.

위의 내용들을 이루기 위해 개발해서 빌드 배포 PRD환경에 제공하는 이 모든 시간을 단축시키고 자동화하는 것이 중요하다.

 

사람을 쓰지 않고, 개발자가 운영을 할 수 있으니까요


## 용어
### ubiquitous Language (유비쿼터스 랭귀지)
도메인에서 사용하는 용어를 코드에 반영하지 않으면 그 코드는 개발자에게 코드의 의미를 해석해야 하는 부담을 준다. <br>
코드의 가독성을 높여서 코드를 분석하고 이해하는 시간을 절약, 용어가 정의 될 때마다 용어 사전에 이를 기록하고 명확하게 정의 함으로써 추후 또는 다른 사람들도 공통된 언어를 사용할 수 있도록 한다.

- 특정 도메인에서 특정 용어가 해당 도메인에서의 의도를 명확히 반영하고, 도메인의 핵심 개념을 잘 전달할 수 있는 언어
- 모든 팀원이 특정 용어를 들었을 때 같은 것을 생각할 수 있는 명확하게 정의된 언어. 같은 용어에 각자 다른 생각을 하거나 같은 것을 말하지만 용어가 다른 경우가 있으면 안된다.
- 도메인에서 사용하는 언어는 코드에 그대로 똑같이 반영되야 한다. 똑같이 반영되지 않으면 개발자는 해당 용어를 해석하고 이해해야하는 부담이 생긴다.
- 유비쿼터스 언어를 사용함으로써 코드의 가독성을 높여 코드를 분석하고 이해하는데 시간을 절약할 수 있다.
- 용어가 정의 될 때마다 용어 사전에 이를 기록하고 명확하게 정의 함으로써 추후 또는 다른 사람들도 공통된 언어를 사용할 수 있도록 한다.

### 도메인
일반적인 요구사항, 소프트웨어로 해결하고자 하는 문제 영역

- 도메인은 한 조직이 행하는 일과 그 조직 안의 세계를 의미합니다.
- 서브 도메인은 어떤 도메인 영역의 상위 도메인이 있는 것을 강조하기 위해 사용하는 용어입니다.
- 서브 도메인은 중요도에 따라 핵심 서브도메인, 지원 서브도메인, 일반 서브도메인으로 나눕니다.
  - 핵심 서브도메인 - 다른 경쟁자와 차별화를 만들 비즈니스 영역이기 때문에 기업의 프로젝트 목록에서 높은 우선순위를 갖는 영역이자 소프트웨어 개발에서 전략적으로 가장 큰 투자가 필요한 영역. 예) 커머스 도메인에서 핵심 서브도메인은 주문, 결졔, 상품, 카테고리 등
  - 지원 서브도메인 - 비즈니스에 필수적이지만 핵심은 아닌 부분으로 볼 수 있다. 그러나 핵심 도메인을 성공시키기 위해서는 반드시 필요한 영역. 핵심 서브도메인 다음으로 중요한 영역. 예) 커머스 도메인에서 지원 서브도메인은 카탈로그, 쿠폰 등
  - 일반 서브도메인 - 비즈니스적으로 특화된 부분은 아니지만 전체 비즈니스 솔루션에는 필요한 부분으로 기존 제품을 구매해서 대체할 수 있다. 예) 커머스 도메인에서 일반 서브도메인은 파일관리, 인증관리 등
- 예시로 든 서브 도메인들은 커머스 도메인이라고 할지라도 회사마다 중요하게 보는 것이 다르기 때문에 달라질 수 있음

### 도메인 모델
특정 도메인을 개념적으로 표현한 것, 도메인 모델을 사용하면 여러 관계자들이 동일한 모습으로 도메인을 이해하고 도메인 지식을 공유하는 데 도움이 된다.

### Entity (엔티티)
테이블 모델, 고유 식별자를 가짐

![alt text](/images/entity.png)

- 엔티티는 다른 엔티티와 구별할 수 있는 식별자를 가진 도메인의 실체 개념을 표현하는 객체이다.
- 식별자는 고유하되 엔티티의 속성 및 상태는 계속 변할 수 있다.
- 식별자가 있기 때문에 데이터베이스로 추적가능하다

### Value Object (벨류 오브젝트)
데이터 표현 모델 식별자를 가지고 있지 않고 불변 타입이다.
```
// 가변 객체 
class Cash {
    private int dollars;

    public void mul(int factor) {
        this.dollars *= factor;
    }
}

// 불변 객체
class Cash {
    private final int dollars;

    public Cash mul(int factor) {
        return new Cash(this.dollars * factor);
    }
}
```

값객체는 각 속성이 개별적으로 변화하지 않는 개념적 완전성을 모델링한다.

<도메인 주도 설계 핵심>의 저자 반 버논은 값객체의 특성을 다음과 같이 정의한다.

- 도메인 내의 어떤 대상을 측정하고, 수량화하고, 설명한다.
- 관련 특징을 모은 필수 단위로 개념적 전체를 모델링한다.
- 측정이나 설명이 변경될 땐 완벽히 대체 가능하다.
- 다른 값과 등가성을 사용해 비교할 수 있다.
- 값 객체는 일단 생성되면 변경할 수 없다.

그 밖에 특성
- 밸류 타입은 불변
- 시스템이 성숙함에 따라 데이터 값을 객체로 대체
- 밸류 객체의 값을 변경하는 방법은 새로운 밸류 객체를 할당하는 것뿐이다.
- 정말 String으로 우편 번호를 표현할 수 있는가?
- 항상 equals() 메서드를 오버라이드할 것을 권고한다.

### Aggregate (에그리게이트)
연관된 엔티티와 벨류 오브젝트의 묶음, 일관성과 트랜잭션, 분산의 단위

루트 레그리게이트 : 에그리게이트가 제공해야 할 핵심 도메인 기능을 보유 하고 있는 모델

![alt text](/images/aggregate.png)

- 관련 객체를 하나로 묶은 군집(1~2개의 엔티티와, 값객체, 표준타입(자바에서 enum)으로 구성)
- 애그리거트는 군집에 속한 객체들을 관리하는 루트 엔티티를 갖는다.
- 이들 간에는 비즈니스 의존관계를 맺고 있으며 비즈니스 정합성을 맞출 필요가 있다. 따라서 애그리거트 단위가 트랜잭션의 기본 단위가 된다.
- 애그리거트로 묶어서 바라보면 좀 더 상위 수준에서 도메인 모델 간의 관계를 파악할 수 있다.
- 애그리거트는 응집력을 유지하고 애그리거트간에는 느슨한 결합을 유지한다.
- 애그리거트에 속한 객체는 유사하거나 동일한 라이프사이클을 갖는다.
- 한 애그리거트에 속한 객체는 다른 애그리거트에 속하지 않는다.
- 두 개 이상의 엔티티로 구성되는 애그리거트는 드물게 존재한다.(대부분 애그리거트 루트만 엔티티이다. - 그 밖의 엔티티가 존재하면, 정말 그 객체가 엔티티가 맞는지 의심해봐야한다. 혹은 드물게 운영상 데이터 추적 혹은 성능상의 이유로 엔티티로 만들기도 한다.)

#### 애그리거트 루트(Aggregate root)
- 애그리거트 내에 있는 엔티티 중 가장 상위의 엔티티를 애그리거트 루트로 정함.
- 애그리거트 루트를 통해서만 애그리거트 내의 엔티티나 값 객체를 변경할 수 있다.(퍼사드 패턴과 유사)
- 애그리거트간의 참조는 직접참조하지 않고 ID참조를 한다.(그림에서 Order가 Buyer를 직접 참조하지 않고 BuyerID로 참조하고 있다.)
- 애그리거트는 단일 트랜잭션으로 일관성을 유지하지만 애그리거트간의 일관성이 필요하다면 도메인 이벤트를 통해 다른 애그리거트를 갱신해서 일관성을 유지한다.

### Bounded Context (바운디드 컨텍스트)
특정한 도메인 모델이 적용되는 제한된 영역 경계 내에선 동일한 모델을 일관되게 적용

![alt text](/images/bounded-context.png)

- 도메인 영역의 경계
- 바운디드 컨텍스트안에서는 유비쿼터스 언어를 사용해야한다.
- 도메인 영역의 경계의 기준은 유비쿼터스 언어를 사용했을 때, 해당 용어의 개념이 달리지는 그 곳을 기준으로 경계를 나눈다.

- 바운디드 컨텍스트 경계
- 고객이라는 도메인은 결제 도메인 입장에서는 신용카드 정보나 계좌 정보를 가진 결제자로서 사용되고 배송 도메인 입장에서는 상품을 받을 주소와 우편번호, 전화번호를 소유한 수취자를 의미한다.
- 도메인 모델은 특정한 컨텍스트 안에서 완전한 의미를 갖는다.
- 바운디드 컨텍스트는 여러개의 서브 도메인으로 구성되고 하나의 서브 도메인은 한 바운디드 컨텍스트에 포함된다.

### Context Map (컨텍스트 맵)
바운디드 컨텍스트 간의 관계

![alt text](/images/context-map.png)

- 컨텍스트 경계를 식별해 내고 이들간의 관계를 표현한 그림을 컨텍스트 맵(Context Map)이라 한다
- 컨텍스트간의 관계는 선으로 표현되고 U는 Upstream으로서 공급자, D는 Downstream으로서 수요자를 나타낸다. 즉 데이터가 흐르는 방향
- 관계는 단방향으로 설정한다.
- 동기 호출은 실선, 비동기 호출은 점선
- 이렇게 도출된 바운디드 컨텍스트는 마이크로서비스 후보가 된다.

### 도메인 이벤트
- 서비스간 정합성을 일치시키기 위해 단위 애그리거트의 주요 상태 값을 담아 전달되도록 모델링한다.
- 이벤트의 용도는 후처리, 데이터 동기화 등
- 도메인 이벤트를 사용하면 애그리거트간, 바운디드 컨텍스트간, 외부 서비스와의 결합을 느슨하게 한다.(도메인 로직이 섞이는 것을 방지)
- 도메인 모델에서 이벤트 주체는 엔티티, 밸류, 도메인 서비스와 같은 도메인 객체이다.
- 도메인 객체는 도메인 로직을 실행해서 상태가 바뀌면 관련 이벤트를 발생한다.
- 스프링에서 제공하는 AbstractAggregateRoot를 애그리거트 루트에 확장하면 애그리거트 루트 내에서 직접 이벤트를 발생할 수 있다(기존의 ApplicationEventPublisher을 사용하면 어플리케이션 레이어에서 이벤트를 발행해야한다)
- 이벤트 핸들러는 서비스 레이어에서 구현하면 된다.


## 이벤트 스토밍
도메인 전문가와 개발자가 같이 참여 하여 어떻게 전략적으로 설계를 효율적으로 할것인가에 대한 방법이다. <br>
이벤트 스토밍은 서비스에 필요한 모든 사람들이 다같이 모여서 진행을 한다. <br>
개발요소가 아닌 이벤트와 비즈니스 프로세스에 집중한다. <br>
팀 구성원 전체가 서비스 이해도를 증가할 수 있고, 도메인 전문가도 이해의 폭을 다시 넓히고 새로운 통찰력을 얻을수 있다.



## 도메인 주도 설계 아키텍처
### 프레젠테이션 레이어
UI 영역이라고 사용하는 데도 있으며 사용자의 요청을 받아 애플리케이션 영역의 처리 결과를 다시 사용자에게 보여주는 역할을 한다.

### 애플리케이션 레이어
사용자에게 제공해야 할 기능을 구현한다.

### 도메인 레이어
도메인 모델을 구현한다. <br>
한 애그리게이트에 넣기 애매한 도메인 개념을 구현하려면 애그리게이트에 억지로 넣기보다는 도메인 서비스를 이용해서 도메인 개념을 명시적으로 드러내면 된다. <br>
도메인 서비스를 사용하는 주체는 애그리게이트가 될 수 있고 응용 서비스가 될 수도 있다.

### 인프라스트럭처 레이어
영속성을 구현하거나 외부와 통신하는 기능을 제공하는 레이어이다.

### DIP (Dependency Inversion Principle, 의존 역전 원칙)
DIP는 의존성 역전 원칙으로 저수준의 모듈이 고수준의 모듈에 의존하면 OCP 원칙을 적용할 수 있다.<br>
도메인 레이어의 서비스에서 사용하는 모듈은 인터페이스로 정의되어 인프라스트럭처 레이어에서 구현되고 있다. <br>
따라서 구현 기술이 변경되더라도 도메인 레이어에서는 동일한 비즈니스 로직을 제공할 수 있고 애플리케이션 성격에 따라 다양한 구현 기술을 적용할 수 있다.

[출처](https://incheol-jung.gitbook.io/docs/q-and-a/architecture/ddd): https://incheol-jung.gitbook.io/docs/q-and-a/architecture/ddd <br>
[출처](https://yoonbing9.tistory.com/121): https://yoonbing9.tistory.com/121