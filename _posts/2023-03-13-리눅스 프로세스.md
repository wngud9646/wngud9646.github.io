---
title:  "리눅스 프로세스"
excerpt: "DevOps 부트캠프 Section 1 "

categories:
  - Blog
tags:
  - [Blog, DevOps]

toc: true
toc_sticky: true
 
date: 2023-03-13
last_modified_at: 2023-03-13
---
# 프로세스와 스레드 <br>
✅ 프로세스 : 운영체제로부터 자원을 할당받은 작업의 단위 <br>
✅ 스레드 : 프로세스가 할당받은 자원을 이용하는 **실행 흐름의 단위** <br><br>

## 프로세스
Process is a program in execution<br>
프로세스란 실행중에 있는 프로그램<br>
메모리에 올라와 실행되고 있는 프로그램의 인스턴스(독립적인 개체)<br>
스케줄링의 대상이 되는 작업(task)와 같은 의미로 쓰인다.<br>
프로세스 내부에는 최소 하나의 스레드(thread)를 가지고 있는데, 실제로는 스레드(thread) 단위로 스케줄링을 한다.<br>
하드디스크에 있는 프로그램을 실행하면, 실행을 위해서 메모리 할당이 이루어지고, 할당된 메모리 공간으로 바이너리 코드가 올라가게 된다. 이 순간부터 프로세스라 불린다.<br><br>
프로세스의 문맥 (context)<br>
CPU 수행 상태를 나타내는 하드웨어 문맥
- Program Counter
- 각종 register
- 프로세스의 메모리 영역
- Code 영역 <br>
실행할 프로그램의 코드나 명령어들이 기계어 형태로 저장된 영역이다. CPU는 코드영역에 저장된 명령어들을 하나씩 처리한다.
- Data 영역<br>
코드에서 선언한 전역 변수와 정적 변수가 저장되는 영역이다. 프로그램이 실행되면서 할당되고 종료되면서 소멸한다.
- Stack 영역<br>
함수 안에서 선언된 지역변수, 매개변수, 리터값등이 저장된다. 함수 호출시 기록되고 종료되면 제거된다.
- Heap 영역
관리가 가능한 데이터 이외의 다른 형태의 데이터를 관리하기 위한 자유공간이다.
- 프로세스 관련 커널 자료 구조 <br>
PCB (Process Control Block)<br>
Kernel Stack
<br><br><br>

## 프로세스의 상태
프로세스는 상태(state)가 변경되며 수행된다.
- Running <br>
CPU 를 잡고 instruction 을 수행중인 상태
- Ready <br>
CPU 를 기다리는 상태
- Blocked (waiting, sleep) <br>
CPU를 주어도 당장 instruction 을 수행할 수 없는 상태
- Process <br>
자신이 요청한 event(예: I/O) 가 즉시 만족되지 않아, 이를 기다리는 상태<br>
(예) 디스크에서 file 을 읽어와야 하는 경우
New : 디스크에서 메모리로 프로그램이 올라가 실행준비를 하는 상태
Terminated : 수행 (execution)이 끝난 상태

### PCB (Process Control Block)
PCB 는 운영체제가 프로세스를 표현한 자료구조이다. <br>
특정 프로세스에 대한 정보를 갖고 있다.<br>
각 프로세스가 생성될때마다 고유의 PCB가 생성되고, 프로세스가 완료되면 PCB 는 제거된다. <br>
프로세스 간 문맥교환이 일어나면서, 프로세스는 진행하던 작업들을 PCB에 저장하고, 이후에 자신의 순서가 왔을 때 이어서 처리한다.<br>
- OS 가 관리상 사용하는 정보<br>
Process state, Process ID
scheduling information, pritoiry
- CPU 수행 관련 하드웨어 값
Program counter, registers<br>
- 메모리 관련<br>
Code, Data, Stack, Heap ..
- 파일 관련<br>
open file descriptors


## 문맥교환 (Context Switch)
하나의 프로세스가 이미 CPU 를 사용중인 상태에서 다른 프로세스가 CPU 를 사용하기 위해 이전 프로세스의 상태를 저장하고 새로운 프로세스의 상태를 적재하는 것.

ex) 카카오톡을 켜놓고 유튜브로 노래를 들으면서 웹서핑을 하는 것은 사용자 입장에서 동시에 일어나는 일처럼 보이지만 실제로는 그렇지 않다. <br>
현재 프로세스 A 가 CPU 를 사용하고 있는 상황에서 CPU 사용시간이 끝나, 다음 프로세스에게 CPU 를 넘겨주어야 한다. <br>스케줄링 알고리즘에 의해 다음 CPU 를 받을 프로세스B 가 선택되었고, 타이머 인터럽트가 발생해 CPU 제어권이 운영체제 커널에 넘어가게 된다.<br>
이 과정에서 운영체제는 타이머 인터럽트 처리 루틴으로 가서 직전까지 수행중이던 프로세스 A 의 문맥을 자신의 PCB 에 저장하고, 프로세스 B 는 예전에 저장했던 자신의 문맥을 PCB로부터 실제 하드웨어로 복원 시키는 과정을 거치 게 된다.

CPU 가 동시에 여러개의 프로세스를 실행시키는 것처럼 보이지만, 사실은 CPU 가 재빠르게 여러 프로세스를 번갈아가며 실행하고 관리하고 있는것. <br>
이때 프로세스를 번갈아가면서 처리하는 것을 Context Switching(문맥교환)이라고 한다.

오버헤드<br>
여기서 문맥교환에 필요한 시간, 메모리
<br>

문맥교환이 아닌 경우 ?<br>
- 프로세스가 실행 상태일 때, 시스템 콜이나 인터럽트가 발생하면 CPU 의 제어권이 운영체제에게로 넘어와, 원래 실행중이던 프로세스의 업무를 잠시 멈추고 운영체제의 코드가 실행된다.
- 이는, 하나의 프로세스가 사용자 모드에서 실행되다가, 커널 모드로 실행 모드만 바뀌는 것일 뿐 CPU 를 점유하는 프로세스가 다른 사용자 프로세스로 변경되는 과정이 아니기 떄문이다. <br><br>


## 스레드
프로세스 하나만을 사용해서 프로그램을 실행하기에는 메모리의 낭비가 발생한다. 스레드는 프로세스와 다르게 스레드 간 메모리를 공유하며 작동한다.

즉, 프로세스가 할당받은 자원을 이용하는 실행 흐름의 단위이다. 스레드는 운영체제의 스케줄러에 의해 독립적으로 관리될 수 있는 프로그래밍된 명령어의 가장 작은 시퀀스이다. 하나의 프로세스는 하나 이상의 스레드를 갖고 있다.
![alt text](/images/process.png)<br><br>


스레드가 독립적으로 가지고 있는 부분
- program counter (→ 실행 흐름)
- register set
- stack space

스레드가 동료 스레드와 공유하는 부분 (=task)
- code section
- data section
- OS resources

전통적인 개념의 heavyweight process 는 하나의 thread 를 가지고 있는 task 로 볼 수 있다.


## 프로세스와 스레드의 차이
운영체제는 프로세스마다 독립된 메모리 영역을 Code/Data/Stack/Heap의 형식으로 할당한다. <br>
각각 독립된 메모리 영역을 할당해주기 때문에 프로세스는 다른 프로세스의 변수나 자료에 접근할 수 없다.

이와 다르게, 스레드는 메모리를 서로 공유할 수 있다. <br>
프로세스가 할당받은 메모리 영역 내에서 Stack 형식으로 할당된 메모리 영역은 따로 할당받고, 나머지 Code/Data/Heap 형식으로 할당된 메모리 영역을 공유한다.<br>
따라서, 각각의 스레드는 별도의 스택을 가지고 있지만 힙 메모리는 서로 읽고 쓸 수 있게 된다.



스레드들이 프로세스의 Code/Data/Heap 메모리 영역을 공유하는 모습

(이미지 출처: Heee's Development Blog )

정리하자면, 프로세스는 운영체제로부터 별도의 메모리 영역을 할당 받고

스레드는 Stack 을 제외한 Code/Data/Heap 부분은 공유해 서로 읽고 쓸 수 있게 된다. (공유자원을 가진다.)

이런 방식으로 메모리를 공유하는 이유?
스레드는 “흐름의 단위로" CPU 의 입장에서 최소 작업 단위가 된다. 반면 운영체제는 이렇게 작은 단위까지 직접 작업하지 않기 때문에 운영체제의 관점에서는 프로세스가 최소 작업단위가 된다.

여기서 중요한 점은 하나의 프로세스는 하나 이상의 스레드를 가진다는 점이다. 따라서, 운영체제 관점에서는 프로세스가 최소 작업 단위인데, 이 때문에 같은 프로세스 소속의 스레드끼리 메모리를 공유하지 않을 수 없다.


### 멀티태스킹, 멀티스레드
멀티태스킹이란 하나의 운영체제 안에서 여러 프로세스가 실행되는 것을 의미한다. <br>
멀티태스킹은 자칫하면 여러 프로세스가 동시에 실행되는 것처럼 보이지만, 자세한 원리를 알아보면 그렇지 않다. <br>
이는 운영체제의 스케줄링 방식에 의해 설명될 수 있다.

멀티태스킹이 하나의 운영체제 안에서 여러 프로세스가 실행되는 것이라면,

멀티스레드는 하나의 프로세스가 여러 작업을 여러 스레드를 사용해 동시에 처리하는 것을 의미한다.<br><br>

🟢 멀티스레드의 장점<br>
Context-Switching 할 때 공유하고 있는 메모리만큼 메모리 자원을 아낄 수 있다.<br>
스레드는 프로세스 내의 Stack 영역을 제외한 모든 메모리를 공유하기 때문에 통신 부담이 적어서 응답 시간이 빠르다.<br>
🔴 멀티스레드의 단점<br>
스레드 하나가 프로세스 내 자원을 망쳐버린다면 모든 프로세스가 종료될 수 있다.<br>
자원을 공유하기 때문에 필연적으로 동기화 문제가 발생할 수 밖에 없다. <br>
교착상태가 발생하지 않도록 주의해야 한다.

+) 동기화 문제란 ? (Synchronization Issue)
멀티스레드를 사용하면 각각의 스레드 중 어떤 것이 어떤 순서로 실행될지 그 순서를 알 수 없다 .만약 A 스레드가 어떤 자원을 사용하다가 B 스레드로 제어권이 넘어간 후 B 스레드가 해당 자원을 수정했을 때, 다시 제어권을 받은 A 가 해당 자원에 접근하지 못하거나, 바뀐 자원에 접근하게 되는 오류가 발생할 수 있다.

이처럼 여러 스레드가 함께 전역 변수를 사용할 경우 발생할 수 있는 충돌을 동기화 문제라고 한다. 스케줄링은 운영체제가 자동으로 해주지 않기 때문에 프로그래머가 적절한 기법을 직접 구현해야 하므로 프로그래밍할 때 멀티스레드를 사용하려면 신중해야 한다.

[출처](https://velog.io/@aeong98/%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9COS-%ED%94%84%EB%A1%9C%EC%84%B8%EC%8A%A4%EC%99%80-%EC%8A%A4%EB%A0%88%EB%93%9C) : 
https://velog.io/@aeong98/%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9COS-%ED%94%84%EB%A1%9C%EC%84%B8%EC%8A%A4%EC%99%80-%EC%8A%A4%EB%A0%88%EB%93%9C

<br><br>

## 포그라운드 백그라운드
### 포그라운드
사용자가 명령어를 입력하면 터미널에서 작업을 입력한 명령을 해석하여 실행한다. 그리고 결과를 화면에 출력한다.<br> 그러면 출력된 결과 화면을 보고 다시 명령을 입력하는 대화식 작업을 수행한다. <br>
입력한 명령어 실행이 결과가 나올 때 까지 기다리는 방식이 바로 포그라운드 방식이다.<br>
포그라운드 프로세스라고 말하며 작업 제어 측면에서는 포그라운드 작업이라고 말한다. <br>
포그라운드 작업은 다른 명령을 입력할 수 없고 기다려서 입력해야한다. 


### 백그라운드
백그라운드 기능은 프로세스가 실행되는 동안 다른 프로세스가 실행 가능하다. <br>
하나의 쉘에서 여러 개의 프로세스를 동시에 실행할 수 있는 방식이다.<br>
백그라운드 방식으로 명령어를 실행하면 곧바로 다음 명령어를 실행 가능하다.<br>
필요한 여러 작업 동시에 진행하면서 포그라운드 작업을 계속 진행할 수 있다.<br> 
백그라운드 작업은 해당 명령어 처리가 오래 걸릴것을 대비해 백그라운드를 이용하면 여러 작업을 동시에 수행할 수 있다.<br>
실행 방법은 & 기호를 추가하면 된다.

[출처](https://gocoder.tistory.com/1814) : https://gocoder.tistory.com/1814

<br><br><br>

# 데몬과 서비스
## 리눅스 데몬
데몬은 유닉스(Unix) 운영체제에서 부팅 시 자동으로 켜져, 백그라운드에서 계속 실행되는 프로세스를 의미한다.

'백그라운드에서 계속 실행되는 프로세스'라는 말에서 알 수 있는 것처럼, 데몬은 프로세스의 범주 안에 속한다.

데몬은 백그라운드 프로세스에 속하기 때문에 백그라운드 프로세스와 마찬가지로 TTY(터미널 장치)를 가지고 있지 않으며, 추가로 PPID(parent id)가 1이고, SID(session id) 역시 자신의 아이디와 같다는 특징이 있다.

유닉스(리눅스를 포함한) 운영체제에서 이름이 'd'로 끝나는 프로세스들이 대표적인 데몬 프로세스라고 볼 수 있으며, 웹서버 또한 서버에서 터미널을 통해 실행될 수는 있지만, tty 또는 pts 등을 사용하여 사용자와 대화할 필요가 없기 때문에 대표적인 데몬 프로세스로 볼 수 있다.

ex) inetd, httpd, nfsd, sshd, lpd, systemd, ftpd, syslogd 등이 있습니다.

데몬이 백그라운드에서 계속 실행되고 있다는 것은 요청이 오면 즉시 대응할 수 있도록 대기 중이라고도 볼 수 있으며, <br>
데몬이 실행되는 방식은 'Stand alond', 'Xinetd' 두 가지이다.

- Stand alone <br>
데몬이 독자적으로 구동되는 방식으로 혼자서 요청을 받아 처리한다. 메모리에 상주하며 항상 구동되고 있기 때문에 요청에 대한 응답 속도가 빨라서 요청이 빈번하게 일어나는 프로세스에 많이 사용된다.<br>
속도는 빠르지만 메모리에 계속 상주하며 구동되고 있기 때문에 부하를 줄 수 있다는 점은 알아두어야 하는 부분이다.<br>
ex) sendmail, apache, mysqld 등이 있다.

* Xinetd<br>
다른 데몬들의 상위에 존재하며, 슈퍼 데몬(Super Daemon)이라고도 불린다.<br>
요청이 왔을 때 자신(xinetd)에게 종속된 하위 데몬을 실행시키는 방식이지만, xinetd 자체는 stand alone 방식으로 동작한다.<br>
하위 데몬의 기준으로 본다면 응답 처리 속도는 위 stand alone 방식에 비해서 느리지만, 요청이 들어오지 않을 때는 휴먼 상태가 되어 메모리를 사용하지 않는다는 장점이 있으며, 요청이 빈번하지 않은 서비스에서 사용된다.<br>
ex) telnet, finger, ftp, shell 등이 있습니다.

윈도우 운영체제에서는 서비스(Service)가 데몬과 같은 역할을 하는 백그라운드 프로세스이다.