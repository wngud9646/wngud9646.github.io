---
title:  "마이크로 서비스 아키텍처 & 모놀리틱 아키텍처"
excerpt: "DevOps 부트캠프 Section 3 "

categories:
  - Blog
tags:
  - [Blog, DevOps]

toc: true
toc_sticky: true
 
date: 2023-05-03
last_modified_at: 2023-05-03
---

![alt text](/images/msa.png) <br><br>

# 모놀리틱 아키텍처
모놀리틱 아키텍처란 비즈니스 로직, DB, UI 등을 하나의 패키지에 담아 빌드하고 배포하는 아키텍처이다.<br>
마이크로서비스 아키텍처의 반대 개념<br>

장점 : 빠르고 쉽게 서비스를 구성할 수 있어 적은 비용으로 서비스를 출시 가능
단점: 코드가 많아지고 복잡해짐에 따라 모놀리틱의 아키텍처의 한계점이 드러난다.
- 부분장애가 전체 서비스의 장애로 확대될 수 있다.
- 소스코드의 수정이 어렵다.
  - 여러 컴포넌트가 하나의 서비스에 강하게 결합되어 있기 때문에 서비스 수정에 대한 영향도 파악이 어려워 수정 개발기간의 지연을 야기한다.
  - 소스코드 테스트를 위한 비용↑
- 한 Framework와 언어에 종속적이다.
  - 새로운 기술의 적용이 어렵다. 예를 들어 블록 체인은 주로 Node.js를 많이 사용하는데 Spring Framework를 사용한다면 Java로 만들어야한다.

모놀리틱 아키텍처의 단점이 드러남에 따라 새로운 아키텍처가 필요하게 된다.

새로운 아키텍처의 필요성
1. 코드 구조의 독립성
2. 기능별 분산된 구조
3. 기능별 최적화된 기술 적용 가능


<br><br><br>

# 마이크로 서비스 아키텍처
마이크로서비스 아키텍처란 하나의 큰 애플리케이션을 여러 개의 작은 애플리케이션으로 쪼개어 변경과 조합이 가능하도록 만든 아키텍처이다.<br>
어플리케이션을 핵심기능 별로 세분화하고 각 기능을 서비스라고 부르며, 독립적으로 구축하고 배포할 수 있다.<br>
서비스는 각자 별도의 프로세스에서 실행되며, HTTP 자원 API 같은 가벼운 매커니즘으로 통신하며 하나의 어플리케이션을 만든다.<br>
각자 가진 네트워크 기능으로 통신할 수 있다.<br>
서비스들은 각자의 비즈니스 기능을 담당하고 완전 자동화된 절차에 따라 독립적으로 배포 가능하다.<br>
서로 다른 프로그래밍 언어나 서로 다른 DB를 사용할 수도 있다

MSA는 어느정도 트래픽이 나오고 서비스가 잘 되었을때 사용해야 한다. <br>
어느 정도 규모가 있어야 유지보수 비용이 줄어들기 때문에 모든 프로젝트에 적합하지는 않다.

장점
- 부하가 집중되는 특정 서비스를 자원을 할당해 스케일 아웃할 수 있기 때문에 효율적인 자원 사용이 가능하다.
  - 스케일 아웃 : 서버의 개수를 늘려 서버의 처리 능력을 향상시키는 것
  - 스케일 업 : 서버 자체의 성능을 증가시키는 것 / 고성능의 서버로 변경
- 서비스의 변경이 다른 서비스에 영향을 미칠 가능성이 적다
- 서비스 단위로 독립적인 배포가 가능하다
- 시스템의 아키텍처가 개발 조직과 나아가서 회사의 조직 문화에 큰 영향을 미친다.
  - 특정 서비스의 개선과 수정 작업이 다른 서비스의 이해 당사자들과 독립적으로 진행될 수 있다.
  - 따라서 의사결정이 빠르고, 독립적인 테스트의 구축이 용이하기 때문에 품질이 증가한다.

단점
- 서비스 간의 통신에 대한 처리가 추가적으로 필요하다
  - 코드의 양이 늘어나고사용자의 요청을 처리하기 위한 응답속도 또한 증가한다.
- 공유 자원 접근이 어렵다.
  - 각 서비스가 독립된 저장소를 갖고 있기 때문에 서비스들끼리 자원을 공유하고 접근하는 것을 구현하기가 어렵고 제약조건도 있다.
- 배포와 실행이 복잡하다.
- 모놀리틱에서는 하나의 프로세스로 실행이 가능했지만, 마이크로서비스는 복잡한 실행 과정을 거쳐야한다. <br>
따라서 모든 서비스들을 한꺼번에 배포하고 실행시키기 위해서는 배포 자동화 과정을 거쳐야만한다.

MSA에서는 각 서비스가 독립적으로 개발, 배포, 운영될 수 있도록 인프라 자동화, CI/CD 파이프라인, 로깅/모니터링, 서비스 디스커버리 등의 기술이 필요하다.


[출처](https://velog.io/@dsunni/%EB%A7%88%EC%9D%B4%ED%81%AC%EB%A1%9C-%EC%84%9C%EB%B9%84%EC%8A%A4-%EC%95%84%ED%82%A4%ED%85%8D%EC%B2%98-%EB%AA%A8%EB%86%80%EB%A6%AC%ED%8B%B1-%EC%95%84%ED%82%A4%ED%85%8D%EC%B3%90): https://velog.io/@dsunni/%EB%A7%88%EC%9D%B4%ED%81%AC%EB%A1%9C-%EC%84%9C%EB%B9%84%EC%8A%A4-%EC%95%84%ED%82%A4%ED%85%8D%EC%B2%98-%EB%AA%A8%EB%86%80%EB%A6%AC%ED%8B%B1-%EC%95%84%ED%82%A4%ED%85%8D%EC%B3%90

<br><br>

## 컴포넌트
컴포넌트(Component)는 재사용 가능한 UI 요소를 말한다. <br>
대부분의 UI 라이브러리와 프레임워크는 컴포넌트 기반 아키텍처를 사용하여 UI를 구축한다.

컴포넌트화(Componentization)란, 이러한 컴포넌트를 생성하고 구성하여 큰 규모의 UI를 구축하는 것을 말한다. <br>
즉, 컴포넌트화는 UI를 작은 단위로 분할하고, 이를 조합하여 전체 UI를 구성하는 것이다. <br>
이를 통해 유지보수성과 재사용성이 향상된다.

컴포넌트화를 위해서는 먼저 UI를 컴포넌트로 분할해야한다. <br>
이때 컴포넌트는 한 가지의 역할을 수행하도록 설계되어야 하며, UI에 필요한 데이터를 입력받을 수 있도록 props와 같은 인터페이스를 제공해야 한다.

컴포넌트화는 대규모 애플리케이션을 관리하기 위한 핵심적인 기술이며, 컴포넌트화를 통해 UI를 더욱 쉽게 관리하고 개발할 수 있다. <br>
또한, 컴포넌트화를 통해 UI의 일부분을 수정하거나 추가하는 등의 작업을 더욱 쉽고 안전하게 수행할 수 있다.

MSA는 소프트웨어를 작은 단위의 서비스로 분리하고, 이들을 독립적으로 개발, 배포, 운영할 수 있도록 하는 아키텍처이다. <br>
각 서비스는 자체적인 데이터베이스와 인프라를 가지며, 서비스 간의 통신은 API를 통해 이루어진다.

이때, 각 서비스는 자체적으로 컴포넌트화된 모듈로 구성되어 있어야 한다. <br>
이는 각 서비스를 작은 단위로 분할하고, 이를 조합하여 전체 서비스 시스템을 구성하기 위함이다. <br>따라서 컴포넌트화는 MSA를 구현하는 데 필요한 요소 중 하나이다.


### 왜 각 서비스는 자체 인프라를 가질까
각 서비스가 자체적인 데이터베이스와 인프라를 가지는 이유는 MSA에서 각 서비스가 독립적으로 개발, 배포, 운영되어야 하기 때문이다.

MSA는 전체 소프트웨어 시스템을 작은 단위의 서비스로 분리하여, 각 서비스를 독립적으로 개발, 배포, 운영할 수 있도록 하는 아키텍처이다. <br>
각 서비스는 다른 서비스와 느슨하게 결합되어 있으며, 각 서비스의 인프라와 데이터베이스는 다른 서비스와 분리되어 있어야 한다.

이렇게 서비스 간에 인프라와 데이터베이스를 분리함으로써, 다음과 같은 이점을 얻을 수 있다.

- 독립적인 개발 및 배포: 각 서비스는 자체적으로 개발 및 배포될 수 있으므로, 다른 서비스와의 의존성이 낮아져 개발과 배포가 편리해진다.
- 수평적 확장: 각 서비스는 독립적으로 확장될 수 있으므로, 전체 시스템의 확장성이 높아진다.
- 결함 격리: 각 서비스는 독립적으로 운영될 수 있으므로, 다른 서비스에서 발생한 결함이 전체 시스템에 영향을 미치지 않는다.
- 보안 강화: 각 서비스의 인프라와 데이터베이스가 분리되어 있으므로, 보안성이 높아진다.



## 도메인
MSA에서 도메인은 MSA의 구성 요소 중 하나로, 비즈니스 기능을 수행하는 서비스의 집합이다.

각 도메인은 특정 비즈니스 영역에 대한 기능을 수행한다. <br>
예를 들어, 전자상거래 시스템에서는 상품, 주문, 결제 등의 도메인이 있을 수 있다. <br>
각 도메인은 자체적으로 데이터베이스와 인프라를 가지며, 독립적으로 개발, 배포, 운영됩니다.

MSA에서는 각 도메인을 마이크로서비스로 분리하여 개발, 배포, 운영한다. <br>
각 마이크로서비스는 특정 도메인에 대한 기능을 수행하며, 다른 마이크로서비스와 느슨하게 결합되어 있다. <br>
이렇게 마이크로서비스를 도메인 단위로 분리하면, 개발 및 배포가 용이해지며, 전체 시스템의 확장성과 유연성이 높아진다.

또한, 각 도메인은 자체적으로 데이터를 관리하며, 다른 도메인과의 데이터 교환은 API를 통해 이루어진다. <br>
이를 통해 도메인 간의 결합도가 낮아지고, 서비스 간의 의존성이 줄어듭니다. 이는 전체 시스템의 유연성과 확장성을 높이는데 기여한다.

<br><br>

## API
MSA에서 API(Application Programming Interface)는 서로 다른 마이크로서비스 간의 통신을 위한 인터페이스이다. <br>
마이크로서비스는 서로 독립적으로 개발, 배포되기 때문에, 서로 다른 기술 스택을 사용할 수 있다. <br>
이 때, API를 통해 서로 다른 기술 스택을 사용하는 마이크로서비스 간의 통신이 가능해진다.

API는 마이크로서비스 간의 통신뿐 아니라, 클라이언트와의 통신에도 사용된다. <br>
클라이언트는 API를 통해 마이크로서비스에 접근하며, 서비스의 기능을 사용할 수 있으며, 이를 통해 마이크로서비스는 자신이 수행하는 비즈니스 기능을 외부에 노출하고, 다양한 클라이언트와 상호작용할 수 있다.


## MSA 구축 순서
1. 비즈니스 요구사항 분석
- 마이크로서비스 아키텍처를 적용하게 된 이유와 그 목적을 분석한다.
- 비즈니스 프로세스를 분석하여 마이크로서비스로 분리할 수 있는 단위를 찾는다.
- 각 마이크로서비스가 제공해야 할 기능과 인터페이스를 정의한다.
2. 서비스 경계 설정
- 각 마이크로서비스의 경계를 설정한다.
- 서비스 경계 설정을 위해 도메인 모델링을 수행한다.
- 서비스 간의 의존성과 연결 관계를 정의한다.
3. 서비스 디자인
- 각 마이크로서비스의 기능을 설계한다.
- 마이크로서비스 간의 인터페이스를 설계한다.
- 데이터베이스와 같은 외부 자원을 사용할 경우, 인터페이스를 설계한다.
4. 기술 스택 선택
- 각 마이크로서비스에 적합한 기술 스택을 선택한다.
- 마이크로서비스 간의 통신을 위한 프로토콜을 선택한다.
- 각 마이크로서비스에서 사용할 데이터베이스와 같은 외부 자원에 대한 기술 스택을 선택한다.
5. 개발 및 배포
- 각 마이크로서비스를 개발한다.
- 각 마이크로서비스를 독립적으로 배포할 수 있도록 구성한다.
- 마이크로서비스 간의 연결 관계를 구성한다.
- 배포 자동화를 구성한다.
6. 운영 및 관리
- 각 마이크로서비스를 운영하고 관리한다.
- 서비스 모니터링을 구성하여 서비스의 상태를 관리한다.
- 서비스의 확장성과 가용성을 관리한다.
- 서비스의 보안과 안정성을 관리한다.




## 서버리스
서버리스(serverless)란 서버가 없다는 것이 아니라, 서버를 관리하는 책임을 클라우드 공급자가 맡아주어 개발자가 서버 인프라를 구성하고 관리하는 일을 줄여주는 방식을 말한다. <br>
이러한 서비스는 FaaS(Function-as-a-Service)나 BaaS(Backend-as-a-Service) 등으로도 불린다.

서버리스는 개발자가 서버 인프라를 구성하지 않아도 서버에서 코드를 실행할 수 있도록 해준다. <br>
개발자는 자신이 작성한 코드(함수)를 서버리스 플랫폼에 업로드하고, 해당 함수가 언제 실행될지에 대해 트리거를 설정하면, 서버리스 플랫폼에서는 해당 함수를 자동으로 실행하고, 그 결과를 반환한다.

서버리스는 클라우드 공급자가 서버 인프라를 관리하기 때문에 개발자는 서버 인프라를 구성하거나 관리할 필요가 없어지고, 코드 실행에 필요한 서버 인프라 자원을 필요한 만큼만 사용하게 된다. <br>
이로 인해 서버리스는 코드 실행에 대한 비용을 절감할 수 있고, 빠른 개발과 배포가 가능해져 더 빠른 시장 진입이 가능해진다.

### 특징
- 서버 인프라를 구성하거나 관리할 필요가 없어지고, 코드 실행에 필요한 서버 자원을 필요한 만큼만 사용할 수 있다.
- 이벤트 트리거에 의해 실행되는 함수 단위로 비용이 청구되므로, 개발 비용과 시간을 절감할 수 있다.
- 서버 인프라 관리와 관련된 복잡성이 줄어들고, 개발자는 더욱 높은 수준의 개발에 집중할 수 있다.


## 서버리스와 MSA
마이크로서비스와 서버리스는 모두 분산 컴퓨팅 아키텍처 중 하나이지만, 둘은 서로 다른 개념이다.

마이크로서비스는 애플리케이션을 작고 독립적인 작업 단위로 나누고, 각각의 단위를 서로 다른 언어와 프레임워크로 개발하고, 각각의 단위를 API를 통해 연결하여 애플리케이션을 구성하는 아키텍처이다.

반면에 서버리스는 서버 인프라를 구성하거나 관리할 필요가 없는 방식으로 코드를 실행하는 아키텍처이다. <br>
개발자는 코드(함수)를 업로드하고, 해당 함수가 언제 실행될지에 대해 트리거를 설정하면, 서버리스 플랫폼에서 해당 함수를 자동으로 실행하고 그 결과를 반환한다.

서버리스는 일반적으로 FaaS(Function-as-a-Service)나 BaaS(Backend-as-a-Service)로 구현됩니다. FaaS는 이벤트 트리거에 의해 실행되는 함수 단위로 비용이 청구되므로, 개발 비용과 시간을 절감할 수 있다. <br>
BaaS는 서버리스 플랫폼에서 제공하는 백엔드 기능(예: 데이터베이스, 인증, 파일 스토리지 등)을 사용하여 개발자가 백엔드를 구성하고 관리할 필요를 없도록 한다.

마이크로서비스와 서버리스는 모두 분산 아키텍처이지만, 마이크로서비스는 애플리케이션의 기능을 여러 서비스로 나누고 서비스 간 통신을 위한 API를 제공하는 방식으로 분산 아키텍처를 구성한다. <br>
반면에 서버리스는 개발자가 코드를 업로드하고 서버리스 플랫폼이 해당 코드를 실행하여 결과를 반환하는 방식으로 분산 아키텍처를 구성한다.

서버리스 아키텍처는 마이크로서비스 아키텍처에서 일부 특징을 반영한다.

첫째, 마이크로서비스 아키텍처는 작고 독립적인 서비스 단위로 애플리케이션을 구성한다. <br>
이러한 서비스는 각각이 서로 다른 언어와 프레임워크로 개발될 수 있다. <br>
서버리스 아키텍처도 비슷한 개념을 따른다. <br>
개발자는 함수 단위로 코드를 작성하고, 이러한 함수는 각각 독립적인 서비스 단위로 취급된다. <br>
따라서 서버리스 아키텍처도 작고 독립적인 서비스를 구성하는 마이크로서비스 아키텍처의 특징을 반영한다.

둘째, 마이크로서비스 아키텍처는 서비스 간 통신을 위한 API를 제공한다. <br>
이러한 API를 통해 서로 다른 마이크로서비스 간 통신이 이루어지며, 이를 통해 애플리케이션을 구성한다.<br>
서버리스 아키텍처도 비슷한 개념을 따른다. <br>
함수는 각각 API 엔드포인트를 가지고 있으며, 다른 함수와 상호작용하고 결과를 반환하기 위해 API를 사용한다.

셋째, 마이크로서비스 아키텍처는 독립적으로 배포 가능한 구성 요소로 구성된다. <br>
마이크로서비스는 각각이 독립적인 배포 가능한 단위로 구성되어 있으므로, 하나의 마이크로서비스에 대한 변경이 다른 마이크로서비스에 영향을 주지 않는다. <br>
서버리스 아키텍처도 마찬가지이다. <br>
함수는 독립적으로 배포 가능한 단위로 구성되어 있으며, 개발자는 필요한 경우 각 함수를 독립적으로 업데이트하고 배포할 수 있다.

### AWS 서버리스 서비스
AWS Lambda: 이벤트에 응답하여 코드를 실행하는 컴퓨팅 서비스이다. <br>
서버리스 아키텍처를 구성할 때 가장 핵심적인 역할을 한다.

Amazon API Gateway: RESTful API를 생성하고 관리하는 서비스로, 요청에 대한 HTTP 엔드포인트를 생성한다. <br>
이 서비스를 사용하면 서버를 구성하지 않고도 API를 생성할 수 있다.

Amazon DynamoDB: NoSQL 데이터베이스 서비스로, 서버리스 애플리케이션에 적합하다. <br>
서버리스 아키텍처에서는 데이터베이스에 대한 스키마를 미리 정의하지 않아도 되기 때문에, DynamoDB와 같은 NoSQL 데이터베이스가 매우 유용하다.

Amazon S3: 객체 스토리지 서비스로, 서버리스 애플리케이션에서 정적 자원을 저장하고 제공하는 데 사용된다. <br>
이 서비스를 사용하면 서버를 구성하지 않고도 정적 파일을 저장하고 제공할 수 있다.

AWS Step Functions: 상태 머신을 사용하여 서버리스 워크플로우를 빌드하고 실행하는 서비스이다. <br>
이 서비스를 사용하면 복잡한 서버리스 애플리케이션을 쉽게 관리할 수 있다.

### 서버리스의 장단점
장점
- 관리 비용 감소: 서버 인프라를 관리하는데 필요한 비용이 감소한다.
- 확장성: 요청에 따라 자동으로 확장하므로 대규모 트래픽 처리가 용이하다.
- 유연성: 필요에 따라 서비스를 추가하거나 제거할 수 있다.
- 개발 생산성 향상: 코드 작성과 배포를 단순화하여 개발 생산성이 향상된다.
- 지속적인 배포: 코드 변경 사항을 빠르게 적용할 수 있어 빠른 개발과 배포가 가능하다.

단점
- 제한된 실행 시간: 함수는 제한된 실행 시간 내에 실행되어야 하기 때문에 장기간 실행되는 서비스에는 적합하지 않다.
- 종속성 문제: 서버리스 환경에서는 각 기능을 독립적으로 구현해야 하므로, 기능 간의 종속성 문제를 고려해야 한다.
- 로컬 개발의 한계: 로컬에서 개발할 때는 서버리스 환경을 완전히 재현하기 어렵기 때문에, 로컬에서의 개발에 어려움이 있을 수 있다.
- 디버깅 문제: 로그 및 이벤트 정보를 수집하여 디버깅해야 하기 때문에, 일반적인 서버 디버깅보다 복잡할 수 있다.

## 질문
### 마이크로서비스와 서버리스는 어떤 관계가 있나요?
둘의 관계는 서버리스 컴퓨팅은 마이크로서비스 구조의 개발을 구성하기 위해 매우 적합한 형태이기 때문이다. <br>
물론 모든 마이크로서비스가 Function 단위의 구조로 개발해야하는 것은 아니지만, 여러 Function들을 구성하고 이들을 독립적인 API 형태로 구성하여 배포하면 마이크로서비스 형태의 애플리케이션이 될 수 있기 때문이다.

또한, Function 단위로 구성된 lamda들을 API Gateway로 처리하여 Load balancer 나 Service discovery 기능을 지원하여 분산형 아키텍처의 고질적인 문제점을 해결할 수 있는 장점도 가지고 있다.

마이크로서비스는 꼭 서버리스로 구현될 필요는 없으며, 서버리스 아키텍처와 마이크로서비스 아키텍처는 필요에 따라 적절히 선택하여 구현할 수 있다.

<br><br>

### 서버리스의 특징 중 하나인 무상태성(Stateless)은 무엇을 의미하나요? 
서버리스 아키텍처의 특징 중 하나인 무상태성(Statelessness)은 서버리스 함수(예: AWS Lambda)가 이전 요청의 컨텍스트와 무관하게 매번 실행될 수 있도록 하는 것을 의미한다. <br>
이전 상태 정보가 저장되지 않으므로 함수 실행 시 필요한 모든 정보는 요청마다 새로 제공되어야 한다.<br> 
이러한 특징으로 인해 서버리스 함수는 일반적으로 가볍고 빠르며 확장성이 용이하다.<br>
또한 무상태성으로 인해 함수의 실행 환경을 독립적으로 관리할 수 있으므로 서로 다른 환경에서 실행되는 여러 함수의 충돌을 방지할 수 있다.

<br><br>

### 마이크로서비스를 구성할 때, 데이터베이스를 꼭 분리해야 하나요? 데이터가 한 곳에 모여있지 않고 중복되어도 괜찮은가요? 모범 사례를 알아보고, 이유를 함께 적어주세요. 
마이크로서비스 아키텍처에서는 데이터베이스를 분리하여 각 마이크로서비스가 독립적으로 개발, 배포, 확장될 수 있도록 하는 것이 일반적으로 권장된다. <br>
이를 통해 각 마이크로서비스는 자신의 데이터를 자유롭게 관리할 수 있으며, 데이터베이스에 대한 엑세스를 표준화할 수 있다. <br>
또한, 데이터베이스를 분리함으로써 각 마이크로서비스는 자신의 데이터를 독립적으로 확장할 수 있다.

하지만, 데이터가 중복되어 있는 것이 상황에 따라서는 오히려 유리할 수도 있다. <br>
예를 들어, 일부 마이크로서비스에서는 같은 데이터를 사용하고자 할 경우, 각 마이크로서비스가 독립적으로 데이터를 관리하는 것이 아니라, 중복된 데이터를 가지는 편이 효율적일 수 있다. <br>
이 경우, 데이터 일관성 등을 유지하기 위해 적절한 데이터 복제 방식이 필요하며, 이를 위한 메커니즘을 구현해야 합니다.

따라서, 데이터베이스를 분리할 것인지, 중복된 데이터를 가지는 것이 유리한지는 상황에 따라 다르며, 이는 마이크로서비스 아키텍처를 구성할 때 고려해야 할 사항 중 하나입니다.

### 예시 사례
Netflix<br>
AdrinaCookcroft가 말하는 마이크로 서비스란?

서비스들이 네트워크를 통해 서로 API통신을 한다.
서비스는 독자적으로 업데이트하며, 서로 영향을 주지않는다.
다른 서비스의 내부구조를 알지 못해도, 내 서비스 코드를 업데이트 할 수 있다


Edge<br>
ElasticLoadBalancer<br>
Zuul : API Gateway<br>
NCCP : Netflix 인증 시스템<br>
API

Netfelx가 가진 마이크로 서비스간 인터페이스 이슈 해결

휴스트릭스
- 외부 마이크로서비스가 일시적 오류가 나면 연동 초기에 차단하여 장애 확대를 초기에 차단, 자신의 서비스를 보호
- Exception이 발생할 경우, 대신 실행캐시로 응답을 미리 만들어서 제공
리본
- CLientSide Load Balancer로서 주어진 서버 목록에 대해 부하분산
유레카
- 서버 리스트를 자동 업데이트해주는 디렉토리 서비스

인프라를 위한 카오스 관리 기법<br>
Netflex는 서비스에 대해 완벽한 신용을 갖지않는다. <br>
오히려 항상 Fail이 일어날것을 대비하는데 이를 위한 대비 방법이 바로 Chaos관리기법이다. <br>
Chaos는 실 서비스에 장애를 주입, 출시 전 테스트에서 드러나지 않은 아키텍처상의 문제를 직접 드러내는 것이다.

Chaos Monkey
- Netflix의 프로덕션 네트워크에서 의도적으로 컴퓨터를 비활성화하여 나머지 시스템이 중단에 어떻게 반응하는지 테스트
Chaos Gorilla
- Simian Army 계층의 맨 위에있는 Chaos Kong은 전체 AWS " Region "을 삭제합니다 . 비록 드문, 지역 전체의 손실이 발생 않으며 카오스 홍콩 이벤트의 유형에 대한 시스템 응답 및 복구를 시뮬레이션합니다.
Chaos Kong
- Chaos Gorilla는 전체 Amazon " 가용 영역 "(지역에 서비스를 제공하는 하나 이상의 전체 데이터 센터)을 삭제합니다.

Netflix로부터 배운 것
- Dependency
- Scale
- Organization & Architecture
- Auto Change