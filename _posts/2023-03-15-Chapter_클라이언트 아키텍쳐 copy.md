---
title:  "서버-클라이언트 아키텍처"
excerpt: "DevOps 부트캠프 Section 1 "

categories:
  - Blog
tags:
  - [Blog, DevOps]

toc: true
toc_sticky: true
 
date: 2023-03-15
last_modified_at: 2023-03-15
---
# 클라이언트-서버 아키텍처
1. 클라이언트/서버 이란?

  ㅇ 클라이언트 (Client)
     - 영어 뜻 자체로는 고객을 의미
        . 클라이언트는 1 이상의 서버 제공 서비스를 사용하는 소비자의 개념
     - 클라이언트/서버 모델에서, 
        . 네트워크를 이용하여 서버(Server)측에 서비스 요청을 의뢰하는 측
           .. 웹 브라우저, 데스크톱 프로그램, 모바일 앱, 다른 서버에 요청을 보내는 서버 등

  ㅇ 서버 (Server)
     - 클라이언트들이 요구하는 각종 서비스를 제공하는 측
        . 특정 역할에 특화된 것
     - 클라이언트/서버 모델에서,
        . 네트워크 상에 구현된 하드웨어 또는 소프트웨어로써, 서비스의 요청을 받는 측


2. 클라이언트/서버 출현배경

  ㅇ 과거에는, 동일 컴퓨터 내에서 호출 및 피호출 프로그램이 상호작용함으로써,
     - 이 둘을 굳이 분리할 필요가 없었음
 
  ㅇ 그러나, 컴퓨터 및 네트워크 기술발전에 따라,
     - 많은 프로그램을 대신하여, 서비스 제공 또는 자원 관리하는 전문화된 프로그램이 널리 확산되어,
     - 이를 서버라 하고 서비스 또는 자원을 의뢰(요청)하는 측을 클라이언트라고 하게됨


3. 클라이언트/서버 모델의 특징

  ㅇ 요청-응답의 형태
     - 이 모델에서의 통신은 항상 요청-응답의 형태를 취함
     - 즉, 클라이언트에 의해서만 시작되고 서버에 의해서는 결코 시작되지 않음

  ㅇ 통상, 한 가지 작업을 전담함 
     - 프린트 서버,고속의 그래픽 서버,데이타베이스 서버,화일 서버,네임 서버,웹 서버 등

  ㅇ 동시 요구 처리 필요함
     - 서버란 많은 다른 클라이언트들의 동시적인 요구를 처리할 수 있도록 설계된 프로세스

  ㅇ 클라이언트/서버 환경
     - 최종 사용자에게는 많은 장점을 제공하는 반면에,
     - 망 운영자에게는 복잡하고 어려운 문제를 끊임없이 제기하게됨

  ㅇ 구성 요소 셋
     - Client,  Server,  Network

  ㅇ 소프트웨어의 위치
     - 변화가 적은 소프트웨어는, 클라이언트측에,
     - 변화가 잦은 소프트웨어는, 서버측에 놓음

  ㅇ 분산처리
     - 클라이언트/서버 모델은 분산협동처리(distributed cooperative processing)
       의 특별한 예라고 할 수 있음
     - 지능형 동배간 처리에서 한 서버는  여유있는 서버에게 계산 부담을 분배함으로써
       서버와 네트워크 특성을 기반으로 하는 분산을 최적화할 수 있음

  ㅇ 서버 이중화
     - 통상, 안정성을 위해 서버 이중화가 요구됨


4. 클라이언트/서버의 TCP/IP 프로토콜

  ㅇ 서버용 소프트웨어
     - HTTP, FTP, 전자우편(SMTP,POP), TELNET, DNS 등

  ㅇ 서버 포트(Port) 관리
     - 서버는 클라이언트가 접근하는 초기 포트로써 잘알려진 포트를 사용하고,
     - 일단 이 포트를 통해 클라이언트와의 연결이 이루어지면,
     - 일반적으로, 서버는 임시 포트(Ephemeral Port)를 생성하여 연결하고, 
     - 이후에는 데이터 교환이 이렇게 유지되는 연결을 통해 이루어지짐


5. 서버 형태 구분

  ㅇ 서버 형태 구분 : 랙 마운트형 서버, 타워형 서버
  ㅇ 서버 등급 구분 : 엔트리 서버, 미들레인지 서버, 하이엔드 서버
  ㅇ 서버 아키텍처 구분 : IA 서버 (Intel Architecture,인텔의 x86 계열) 등

  [출처](http://www.ktword.co.kr/test/view/view.php?m_temp1=474) : 
  http://www.ktword.co.kr/test/view/view.php?m_temp1=474
<br><br>

  ### 프론트엔드 백엔드
  프론트엔드: 인터페이스(User Interface), 사용자가 볼 수 있는 화면. 웹사이트에서 나타나는 텍스트나 이미지 그리고 버튼을 클릭하는 것 등 사용자가 마주하는 '앞단'의 영역 <br><br>

  백엔드: 사용자들이 원하는 정보를 제공할 수 있도록 데이터를 관리하거나 서버를 운영하는 등 '뒷단'의 영역


  ### 다층 구조(Multi-tier Architecture)
  비즈니스 로직을 완전히 분리하여 데이터베이스 시스템과 클라이언트의 사이에 배치한 클라이언트 서버 시스템의 일종이다.<br>
  예를 들어 사용자와 데이터베이스간의 데이터 요구 서비스에 미들웨어를 이용하는 것을 들 수 있다. 일반적으로는 3층 구조가 널리 쓰인다.

  - 3층 구조 (3-Tier)<br>
  3티어 아키텍처란 사용자 인터페이스, 비즈니스 로직, 데이터베이스를 말하며, 이들을 각각 독립된 모듈로 개발하고 유지하는 구조로, 일반적으로 이들은 각각 다른 플랫폼 상에서 구동된다.<br>
  3티어 아키텍처는 2티어 아키텍처의 제한을 극복하기 위해서 탄생한 구조로, 사용자 인터페이스 환경과 데이터베이스 관리서버 환경 사이의 중간층이 추가된 구조이다. <br>
  중간층의 구현은 트랜잭션 처리 모니터, 메시지 서버, 응용 서버 등 여러 가지 방법으로 구축될 수 있다. <br>
  이러한 중간층은 데이터베이스의 다단계나 응용 프로그램의 실행 또는 사용자 요구 분산을 위한 큐잉을 수행할 수 있다. <br>
  예를 들어, 중간층이 큐로써 역할을 한다면 클라이언트는 자신의 요청을 중간층에 전달만 하고 중간층이 서버에 접속해서 클라이언트가 남기고 간 요청에 대한 응답을 받아 클라이언트에 돌려줄 것이다. <br>
  이러한 중간층의 역할은 스케줄링을 가능하게 할 뿐만 아니라, 다수 사용자 요구 처리에 대한 우선 순위를 정할 수 있게 해주어 서버의 부하를 줄여준다.<br>

  3층 구조는 아래의 세 층으로 나뉘어 있다.<br>

  - 프레젠테이션 계층<br>
  프레젠테이션 계층은 응용 프로그램의 최상위에 위치하고 있는데 이는 서로 다른 층에 있는 데이터 등과 커뮤니케이션을 한다.<br>

  - 애플리케이션 계층<br>
  이 계층은 비즈니스 로직 계층 또는 트랜잭션 계층이라고도 하는데, 비즈니스 로직은 워크스테이션으로부터의 클라이언트 요청에 대해 마치 서버처럼 행동한다.<br>
  그것은 차례로 어떤 데이터가 필요한지를 결정하고, 메인프레임 컴퓨터 상에 위치하고 있을 세 번째 계층의 프로그램에 대해서는 마치 클라이언트처럼 행동한다.<br>

 - 데이터 계층 <br>
 데이터 계층은 데이터베이스와 그것에 액세스해서 읽거나 쓰는 것을 관리하는 프로그램을 포함한다. <br>
 애플리케이션의 조직은 이것보다 더욱 복잡해질 수 있지만, 3계층 관점은 대규모 프로그램에서 일부분에 관해 생각하기에 편리한 방법이다.

 [출처](https://ko.wikipedia.org/wiki/%EB%8B%A4%EC%B8%B5_%EA%B5%AC%EC%A1%B0) : https://ko.wikipedia.org/wiki/%EB%8B%A4%EC%B8%B5_%EA%B5%AC%EC%A1%B0

<br><br>

 ## 프로토콜
프로토콜(protocol)은 '약속', '규약', '협약' 등을 의미하는 단어로, 네트워크 분야 외에도 여러 분야에서 통용된다. <br>
상호 간 원활한 교류, 소통, 통신을 위해 서로 동일하게 어떠한 설정/규칙을 정한다는 뜻이다. 전화 통화 시 '여보세요'라고 시작하는 게 사회적 협약인 것과 같다.

컴퓨터 네트워크 환경 내 모든 기기가 서로 통신하며 데이터를 주고 받으려면, 각 기기에는 사전 협의된 통신 협약/규약이 필요하다.<br>
이 규약을 '네트워크 프로토콜'이라 하는데, 현존하는 네트워크 프로토콜은 수십 여종이 있다.


### TCP/IP
컴퓨터 네트워크에서 TCP/IP 프로토콜은 인터넷 연결에 있어 핵심이면서 대단히 중요한 역할을 한다. 어디선가 얼핏 보고 들은 듯한 TCP/IP는, 'TCP 프로토콜'의 특성과 'IP 프로토콜'의 특성을 합친 것이다. 즉 IP주소 체계(IP 프로토콜의 특성)를 통해, 신뢰성 높은 데이터 송수신(TCP 프로토콜의 특성)을 보장한다.

윈도우 운영체제의 '네트워크 및 인터넷 설정' 항목을 보면, 'Internet Protocol Version 4(TCP/IPv4)'와 'Internet Protocol Version 6(TCP/IPv6)' 옵션이 있는데, 현재 우리가 사용하는 TCP/IP 버전이 'v4'다.

TCP/IPv6는 현행 v4의 IP주소 구조를 확장해, IP주소 고갈/부족 문제를 해결할 수 있다. 다만 대중적으로 확산되기까지 시간이 좀더 필요하다.

'IP주소', '서브넷마스크', '게이트웨이 주소', 'DNS 서버 주소' 등을 통해 인터넷 웹사이트에 접근하려면, 해당 웹사이트 서버와 사용자 PC는 모두 TCP/IP 프로토콜을 사용한다는 규약이 적용돼 있어야 한다.
<br><br>

### HTTP
일반적으로 웹브라우저로 특정 홈페이지를 여는 건 '인터넷 접속'의 한 방식일 뿐이다. <br>인터넷 홈페이지/웹페이지는 기본적으로 '하이퍼 텍스트(hyper-text)'라는 프로그래밍 언어(HTML)로 제작되는데, 이 하이퍼 텍스트 웹페이지를 제공, 제어하는 프로토콜이 HTTP(Hyper Text Transfer Protocol)다.

웹브라우저 주소창에 'http://~'라 입력하는 건, HTTP 프로토콜을 통해 HTML로 제작된 웹페이지에 연결하겠다는 의미다. <br>
즉 여기서 'http' 대신 다른 프로토콜(예, ftp)을 입력하면 다른 방식으로 해당 사이트에 접속하게 된다.

참고로, 요즘에는 웹브라우저 주소창에 'http'를 따로 입력하지 않아도, http가 자동 포함된 것으로 간주된다. <br>
아울러 http가 아닌 'https' 프로토콜도 많이 사용되는데, 이는 http와 동일하지만 보안(Secure) 기능을 추가한 것이다.

https 프로토콜은 서버와 PC 간 송수신되는 데이터를 암호화하는데, 대개 홈페이지 로그인이나 회원가입, 온라인 결제 등에 자동 적용된다.
<br><br>

### FTP
파일 송수신 만을 위한 최소한의 환경만 제공해 다른 프로토콜보다 파일 송수신 속도가 빠르다.<br> 위 HTTP 프로토콜로도 파일 송수신(업로드/다운로드)은 가능하지만, 많은 파일을 처리하기에는 적합하지 않다. <br>
이에 FTP(File Transfer Protocol)는 대량의 파일을 빠르게 송수신할 수 있는 프로토콜이다.

특정 사이트가 ftp 서비스를 제공한다면, 앞선 'http://~' 주소창에 'http' 대신 'ftp를 넣어 'ftp://~' 형식으로 FTP 서비스에 접속할 수 있다.<br>
즉 인터넷 주소가 같아도 http로 접속하는 사이트와 ftp로 접속하는 사이트는 서로 다르다.

일반 웹브라우저나 윈도 탐색기로도 ftp 사이트에 접속할 수 있지만, 아무래도 FTP 전용 프로그램을 사용하는 게 여러 모로 편리하다. <br>
'알드라이브(구. 알FTP)'나 'FileZilla(파일질라)' 같은 무료 프로그램이 있다. 이들 프로그램은 사용자 PC를 FTP 서버로도 운영할 수 있는 서버 기능도 제공한다.


### SMTP, POP
인터넷으로 이메일을 보내고 받을 때도, 서버와 사용자간 상호 규약이 필요하다.<br> 
메일 보낼 때는 SMTP 프로토콜을, 받을 때는 POP 프로토콜을 사용한다. (SMTP = Simple Mail Transfer Protocol, POP = Post Office Protocol)

대부분 네이버 메일이나 다음 메일, 구글 지메일 등의 이메일 서비스를 사용할 텐데, 각 홈페이지에서 메일을 보내고 받을 때는 이들 프로토콜에 대해 굳이 알 필요는 없다. <br>
각 포털의 메일 서버에 미리 설정돼 있기 때문이다.

다만 메일 송수신 전용 프로그램(윈도우10 '메일' 앱 등)을 사용하려 한다면, 해당 포털의 메일 서버의 SMTP 설정과 POP 설정을 직접 입력해야 한다(이 설정 정보는 각 포털에 공개돼 있다).<br>
이를 설정하면 해당 포털의 메일 홈페이지에 접속하지 않아도, 메일 프로그램을 통해 바로 메일 송수신이 가능하다.<br>
포털 사이트가 아닌, 자체 메일 서버를 구축, 운영 중인 기업/기관 내 사용자라면 알아둘 만하다.

참고로, 메일 수신 프로토콜로 POP 외 'IMAP'이라는 프로토콜도 자주 사용된다(Internet Messaging Access Protocol). <br>
몇 가지 특징이 있을 뿐 POP와 동일한 역할이다.

<br>

### DHCP
IP주소+서브넷마스크+게이트웨이 주소+DNS 서버 주소 등의 인터넷 주소 세트를 자동으로 할당 받아 설정하는 프로토콜이다. <br>
즉 DHCP 서버의 자동 할당 설정에 따라, 사용자 PC도 DHCP 서비스를 실행해 인터넷 주소를 자동 할당 받는다. 윈도를 비롯해 PC용 운영체제는 기본적으로 DHCP 서비스가 자동 실행된다.

[출처](https://it.donga.com/31842/) : 
https://it.donga.com/31842/


## TCP/UDP
### TCP
TCP는 신뢰성 있는 데이터 전송을 지원하는 연결 지향형 프로토콜이다. <br>
일반적으로 TCP와 IP가 함께 사용되는데, IP가 데이터의 전송을 처리한다면 TCP는 패킷 추적 및 관리를 하게된다. <br>
연결 지향형인 TCP는 3-way handshaking이라는 과정을 통해 연결 후 통신을 시작하는데, 흐름 제어와 혼잡 제어를 지원하며 데이터의 순서를 보장한다.

흐름 제어: 보내는 측과 받는 측의 데이터 처리속도 차이를 조절해주는 것
혼잡 제어: 네트워크 내의 패킷 수가 넘치게 증가하지 않도록 방지하는 것
 
🔎 특징
연결형 서비스로 가상 회선 방식을 제공
데이터의 전송 순서 보장
데이터의 경계를 구분하지 않음
신뢰성 있는 데이터 전송
UDP보다 전송속도가 느림
연결을 설정(3-way handshaking)과 해제(4-way handshaking)


### UDP
⭐️ UDP(User Datagram Protocol)
UDP는 비연결형 프로토콜로써, 인터넷상에서 서로 정보를 주고받을 때 정보를 보낸다는 신호나 받는다는 신호 절차를 거치지 않고 보내는 쪽에서 일방적으로 데이터를 전달하는 통신 프로토콜이다.<br> 
TCP와는 다르게 연결 설정이 없으며, 혼잡 제어를 하지 않기 때문에 TCP보다 전송 속도가 빠르다. 그러나 데이터 전송에 대한 보장을 하지 않기 때문에 패킷 손실이 발생할 수 있다.

🔎 특징
비연결형 서비스로 데이터그램 방식을 제공
비신뢰성
데이터의 경계를 구분
패킷 오버해드가 적어 네트워크 부하 감소
혼잡 제어를 하지 않기 때문에 TCP보다 빠름
TCP의 handshaking 같은 연결 설정이 없음


|TCP(Transfer Control Protocol)|UDP(User Datagram Protocol)|
|------|---|
|연결형 프로토콜|비연결형 프로토콜|
|데이터의 경계를 구분하지 않음|데이터의 경계를 구분함|
|신뢰성있는 데이터 전송 (데이터 재전송 존재O)|비신뢰성 데이터 전송 (데이터 재전송 존재X)|
|일 대 일(Unicast) 통신 | 일 대 일, 일 대 다(Broadcast), 다 대 다(Multicast) 통신 |

![alt text](/images/tcpudp.png)<br><br><br>
[출처](https://cocoon1787.tistory.com/757) : 
https://cocoon1787.tistory.com/757

## API
API(application programming interface 애플리케이션 프로그래밍 인터페이스, 응용 프로그램 프로그래밍 인터페이스)는 컴퓨터나 컴퓨터 프로그램 사이의 연결이다. <br>
일종의 소프트웨어 인터페이스이며 다른 종류의 소프트웨어에 서비스를 제공한다. <br>
이러한 연결이나 인터페이스를 빌드하거나 사용하는 방법을 기술하는 문서나 표준은 API 사양으로 부른다.<br> 이 표준을 충족하는 컴퓨터 시스템은 API가 구현(implement)되었다거나 노출(expose)되었다고 말한다. API라는 용어는 사양이나 구현체를 의미할 수 있다.   -위키백과

멋진 레스토랑에 있다고 가정해볼 때, 점원이 가져다준 메뉴판을 보면서 먹음직스러운 스테이크를 고르면, 점원이 주문을 받아 요리사에 요청을 한다.<br>
그러면 요리사는 정성껏 스테이크를 만들어 점원에게 주고, 여러분은 점원이 가져다준 맛있는 음식을 먹을 수 있게된다. <br>
여기서 점원의 역할을 한 번 살펴본다면, 점원은 손님에게 메뉴를 알려주고, 주방에 주문받은 요리를 요청합니다. 그다음 주방에서 완성된 요리를 손님께 다시 전달한다.<br>
API는 점원과 같은 역할을 한다. <br>

![alt text](/images/easyapi.png)<br><br><br>

API는 손님(프로그램)이 주문할 수 있게 메뉴(명령 목록)를 정리하고, 주문(명령)을 받으면 요리사(응용프로그램)와 상호작용하여 요청된 메뉴(명령에 대한 값)를 전달한다. <br>
쉽게 말해, API는 프로그램들이 서로 상호작용하는 것을 도와주는 매개체로 볼 수 있다.


### API의 역할 
1. API는 서버와 데이터베이스에 대한 출입구 역할을 한다.
: 데이터베이스에는 소중한 정보들이 저장된다. 모든 사람들이 이 데이터베이스에 접근할 수 있으면 안 될것이다. API는 이를 방지하기 위해 여러분이 가진 서버와 데이터베이스에 대한 출입구 역할을 하며, 허용된 사람들에게만 접근성을 부여한다.

2. API는 애플리케이션과 기기가 원활하게 통신할 수 있도록 한다.
: 여기서 애플리케이션이란 우리가 흔히 알고 있는 스마트폰 어플이나 프로그램을 말한다. API는 애플리케이션과 기기가 데이터를 원활히 주고받을 수 있도록 돕는 역할을 한다.

3. API는 모든 접속을 표준화한다.
API는 모든 접속을 표준화하기 때문에 기계/ 운영체제 등과 상관없이 누구나 동일한 액세스를 얻을 수 있다. 쉽게 말해, API는 범용 플러그처럼 작동한다고 볼 수 있다.


### API 유형
API유형은 어떤게 있을까?
1. private API <br>
private API는 내부 API로, 회사 개발자가 자체 제품과 서비스를 개선하기 위해 내부적으로 발행한다. 따라서 제 3자에게 노출되지 않는다.

2. public API <br>
public API는 개방형 API로, 모두에게 공개된다. 누구나 제한 없이 API를 사용할 수 있는 게 특징이다.

3. partner API <br>
partner API는 기업이 데이터 공유에 동의하는 특정인들만 사용할 수 있다. 비즈니스 관계에서 사용되는 편이며, 종종 파트너 회사 간에 소프트웨어를 통합하기 위해 사용된다.


### API의 장점
Private API를 이용할 경우, 개발자들이 애플리케이션 코드를 작성하는 방법을 표준화함으로써, 간소화되고 빠른 프로세스 처리를 가능하게 한다. 또한, 소프트 웨어를 통합하고자 할 때는 개발자들 간의 협업을 용이하게 만들어줄 수 있다.
public API와 partner API 를 사용하면, 기업은 타사 데이터를 활용하여 브랜드 인지도를 높일 수 있다. 뿐만 아니라 고객 데이터베이스를 확장하여 전환율까지 높일 수 있다.

[출처](https://blog.wishket.com/api%EB%9E%80-%EC%89%BD%EA%B2%8C-%EC%84%A4%EB%AA%85-%EA%B7%B8%EB%A6%B0%ED%81%B4%EB%9D%BC%EC%9D%B4%EC%96%B8%ED%8A%B8/) :
https://blog.wishket.com/api%EB%9E%80-%EC%89%BD%EA%B2%8C-%EC%84%A4%EB%AA%85-%EA%B7%B8%EB%A6%B0%ED%81%B4%EB%9D%BC%EC%9D%B4%EC%96%B8%ED%8A%B8/


## HTTP 요청 메소드
클라이언트가 웹 서버에게 사용자 요청의 목적/종류를 알리는 수단이다. <br>
최초의 HTTP에서는 GET 메소드 하나밖에 존재하지 않았고, 당시 서버로부터의 응답은 무조건 HTML 문서였다.
1. HEAD : 메세지 헤더(문서 정보) 취득
     GET과 유사한 방식이지만, 실제 문서를 요청하는 것이 아니라, 문서 정보를 요청하는 것이다. <br>
     이에 따라 HTTP 응답 메세지에 본문(Body)없이 HTTP 헤더 정보만을 보냄.
     ![alt text](/images/head.png) <br><br>

2. GET: URI 형식으로 웹 서버측 리소스(데이터)를 요청
     <br>
     파라미터를 넘겨서 해당하는 본문형식을 받는다. 
     ![alt text](/images/get.png) <br>
     위 그림처럼 URI형식으로 서버에 요청해 데이터를 받는다. <br>
     그러므로 본인이 서버에 파라미터를 날릴 때 url에 찍히는 것이 보기 싫다면 POST로 요청해야한다.

3. POST: 내용 전송(파일 전송 가능)
     클라이언트에서 서버로 전달하고자하는 정보를 서버로 보냄
     ![alt text](/images/post.jpg) <br><br>

4. PUT: 내용 갱신 위주(파일 전송 가능) <br>
     POST처럼 정보를 서버로 제출하는 것이나 보통 갱신 위주다.

5. DELETE: 파일 삭제<br>
     웹 리소스를 제거할 때 사용한다. 하지만, DELETE의 경우 서버에서 클라이언트의 요청을 무시 가능하기 때문에 실제로 삭제되지 않았지만, 클라이언트는 파일이 삭제 되었다고 생각할 수 있다.

6. OPTIONS: 웹 서버측 제공 메소드에 대한 질의 <br>
     가능한 메소드 옵션에 대한 질의이다. <br>
     이 경우 응답 메세지에 HTTP 헤더 항목 중 'Allow: GET, POST, HEAD'처럼 보내게 된다.

7. TRACE: 요청 리소스가 수신되는 경로를 보여줌. <br>
     자기 앞으로 요청 메세지를 반환(루프백) 시험

8. CONNECT:  프록시 서버와 같은 중간 서버 경유 <br>
     이 메소드는 요청한 리소스에 대해 양방향 연결을 시작하는 메소드다. <br>
     CONNECT 메소드는 SSL(HTTPS)를 사용하는 웹 사이트 접속하는데 사용할 수 있다. <br>
     클라이언트는 원하는 목적지와 TCP연결을 HTTP 프록시 서버에 요청한다. 그러면 서버는 클라이언트 대신하여 연결의 생성을 진행한다. <br>
     한번 서버에 의해 연결이 수립되면, 프록시 서버는 클라이언트에 오고가는 TCP 스트림을 계속해서 프록시한다. <br><br>


![alt text](/images/request_table.png) <br><br>

[출처](https://zorba91.tistory.com/136) :
https://zorba91.tistory.com/136

<br><br>

## URL
URL(Uniform Resource Locator)이란 사용자가 원하는 정보의 위치와 종류를 파악할 수 있도록 웹페이지의 정보 구조를 반영한 것이다. 그렇기 때문에 웹페이지의 정보 구조가 제대로 반영된 URL은 좋은 UX(사용자 경험)이며 이는 SEO(검색엔진최적화) 기획에서 중요한 지표이다. URL의 구성 및 구성 요소는 사용자 경험, SEO 외에도 해당 웹사이트의 보안에도 중요하다.

### URL 구조
![alt text](/images/url.png)
URL은 프로토콜, 호스트(도메인, 포트), 서브 디렉토리, 웹 페이지로 이루어져 있지만 대부분의 웹사이트는 프로토콜, 도메인, 서브 디렉토리 정도만 표시된다. <br>

- 프로토콜 <br>
프로토콜이란 웹사이트에서 서버와 클라이언트간에 어떤 방법으로 자원을 접근할지 알려주는 통신 규악 중 하나이다. <br>
URL의 가장 앞 부분에 위치하고 있는데 이메일 주소를 지정하는 프로토콜인 mailto:, 파일을 주고받는 프로토콜인 ftp: 등이 있다. <br>
그 중 웹브라우저에서 가장 많이 사용되는 프로토콜인 https:, http:는 웹브라우저와 웹서버 사이에서 웹문서 및 구성 자원을 전송하기 위한 프로토콜이다.<br>
많은 웹사이트들이 https를 기본 프로토콜로 사용하고 있으며 이는 http 보다 보안이 강화된 버전이다.

- 도메인 <br>
도메인이란 URL에서 웹서버의 위치를 지정하는 부분이다. 주로 www.example.com과 같은 도메인 이름으로 사용하지만 123.0.0.1과 같은 IP 주소로도 사용할 수 있다. <br>
예시 도메인에서 www. 부분을 서브 도메인 혹은 호스트 이름이라고 부르며 이는 특정 웹사이트에 접근하는 데 사용된다. <br>
다음으로 나오는 example.com이  도메인 이름으로 네트워크상에서 컴퓨터를 식별하는 호스트명이다. <br>
도메인 뒤에 나오는 :443은 포트번호라고 한다.<br>
포트번호는 웹서버에서 자원을 접근하기 위해 사용하는 게이트 번호이며 표준 http에서는 80, https에서는 443이며 공통의 약속이다 보니 굳이 작성하지 않아도 브라우저가 알아서 처리해서 보여준다.

- 서브 디렉토리 <br>
서브 디렉토리란 해당 페이지가 위치한 파일 시스템의 경로로서 웹 페이지 또는파일을 구성하는 데 사용되는 디렉토리를 나타낸다.<br>
서브 디렉토리를 통해 페이지가 현재 어느 페이지의 하위로 들어가 있는지 확인 가능하다.


## URI
URI는 특정 리소스를 식별하는 통합 자원 식별자(Uniform Resource Identifier)를 의미한다. 웹 기술에서 사용하는 논리적 또는 물리적 리소스를 식별하는 고유한 문자열 시퀀스다
비록 URL은 URI의 서브셋이지만 URI와 URL의 가장 큰 차이점은 바로 아래와 같다
> URI는 식별하고, URL은 위치를 가르킨다.

또다른 단순한 구별법으로 쿼리를 붙이거나, 북마크를 포함하면 이것은 URI지만, URL은 아니다.


### URI의 구조
일반 URI는 다음과 같은 형태를 나타낸다.
> scheme:[//[user[:password]@]host[:port]][/path][?query][#fragment]

1. scheme : 사용할 프로토콜을 뜻하며 웹에서는 http 또는 https를 사용
2. user와 password : (서버에 있는) 데이터에 접근하기 위한 사용자의 이름과 비밀번호
3. host와 port : 접근할 대상(서버)의 호스트명과 포트번호
4. path : 접근할 대상(서버)의 경로에 대한 상세 정보
5. query : 접근할 대상에 전달하는 추가적인 정보 (파라미터)
6. fragment : 메인 리소스 내에 존재하는 서브 리소스에 접근할 때 이를 식별하기 위한 정보

[출처](https://www.charlezz.com/?p=44767) :
https://www.charlezz.com/?p=44767

<br><br>

## IP
OSI 7계층 중에서 3계층인 네트워크 계층에서 생성 및 사용되는 IP 주소는 네트워크 환경에서 내 컴퓨터의 주소라고 볼 수 있다. 
![alt text](/images/ip.png)
여기서 네트워크 주소는 공통적인 부분이고, 호스트 주소가 중복이 없고 유일한 식별자 역할을 한다. <br>
이러한 IP주소는 실제로는 32자리의 2진수로 이뤄져있고, 위에 나온 IP주소 192.168.0.103을 2진수로 표기하면 다음과 같이 된다. 
> 11000000.10101000.00000000.01100111

IP는 8비트인 각각의 영역을 옥텟지칭하여 구분하며 4개의 오텟을 dot(.)으로 구분한다. 
즉 IP는 00000000.00000000.00000000.00000000 ~ 11111111.11111111.11111111.11111111 까지 대략 0 ~ 2^32개 정도를 만들 수 있다. 이렇게 구분된 IP 주소체계를 IPv4f라고 한다.<nr>
(하지만 현재 대부분 사용이 되고있어서 IPv6표현으로 대체중이다.)
[출처](https://catsbi.oopy.io/15f97a5f-acc8-410e-afab-0b26adff89c5) : 
https://catsbi.oopy.io/15f97a5f-acc8-410e-afab-0b26adff89c5

### IPv6
인터넷 보급률이 낮았던 초기에는 IPv4(IP version 4)으로 네트워크에 연결된 PC에 주소를 할당하는 일이 가능했다. <br>
그러나 개인 PC의 보급으로 전 세계의 누구나 PC를 이용해 인터넷에 접속하고, 각종 서비스를 위해 서버를 생산하면서 IPv4로 할당할 수 있는 PC가 한계를 넘어서게 되었다. <br>
이를 해결하기 위해서 세상에 나오게 된 것이 IPv6(IP version 6) 이다. <br>
IPv6는 표기법을 달리 책정하여 2^(128)개의 IP 주소를 표현할 수 있다.

<br><br>

### 용도가 정해진 IP주소
- localhost, 127.0.0.1 : 현재 사용 중인 로컬 PC를 지칭한다.
- 0.0.0.0, 255.255.255.255 : broadcast address, 로컬 네트워크에 접속된 모든 장치와 소통하는 주소이다.
- 서버에서 접근 가능 IP 주소를 broadcast address 로 지정하면, 모든 기기에서 서버에 접근할 수 있다.


## 포트(Port)
Port(포트)란 IP 내에서 애플리케이션 상호 구분(프로세스 구분)을 위해 사용하는 번호이다.<br>
포트 숫자는 IP 주소가 가리키는 PC에 접속할 수 있는 통로(채널)을 의미한다.<br>
터미널에서 리액트를 실행하면 나타나는 화면에는, 로컬 PC의 IP 주소인 127.0.0.1 뒤에 :3000과 같은 숫자가 표현된다.<br>
리액트를 실행했을 때에는 로컬 PC의 IP 주소로 접근하여, 3000번의 통로를 통해 실행 중인 리액트를 확인할 수 있다.<br>
이미 사용 중인 포트는 중복해서 사용할 수 없다.<br>
만약 다른 프로그램에서 3000번 포트를 사용 중이라면, 3001번 포트 번호로 리액트가 실행된다.<br>
포트 번호는 0~ 65,535 까지 사용할 수 있다.<br>
그 중에서 0 ~ 1024번 까지의 포트 번호는 주요 통신을 위한 규약에 따라 이미 정해져 있다.


### 반드시 알아야하는 포트 번호
- 22 : SSH
- 80 : HTTP
- 443: HTTPS
<br><br><br>


# DNS
- 웹사이트에 접속 할 때 우리는 외우기 어려운 IP 주소 대신 도메인 이름을 사용한다.
- 도메인 이름을 사용했을 때 입력한 도메인을 실제 네트워크상에서 사용하는 IP 주소로 바꾸고 해당 IP 주소로 접속하는 과정이 필요하다.
- 이러한 과정, 전체 시스템을 DNS(도메인 네임 시스템)라고 한다.
- 이러한 시스템은 전세계적으로 약속된 규칙을 공유한다.
- 상위 기관에서 인증된 기관에게 도메인을 생성하거나 IP 주소로 변경할 수 있는 ‘권한’을 부여한다.
- DNS는 이처럼 상위 기관과 하위 기관과 같은 ‘계층 구조’를 가지는 분산 데이터베이스 구조를 가진다.
<br><br>

## DNS 구성 요소
1. 도메인 네임 스페이스(Domain Name Space):<br>
도메인 이름을 분산저장하는 규칙(방법)
2. 네임 서버(Name Server) = 권한 있는 DNS 서버 : <br> 도메인 이름의 IP 주소를 찾는다.
3. 리졸버(Resolver) = 권한 없는 DNS 서버 <br>
DNS 클라이언트 요청을 네임 서버로 전달하고 찾은 정보를 클라이언트에게 제공하는 기능을 수행한다.<br>
어떤 네임 서버에서 찾아야하는지, 이미 캐시 되어있는지 등 어떻게든 찾아서 클라이언트에게 찾았으면 찾은 것을 못 찾았으면 못 찾았다고 전달하는 역할을 한다. <br>
리졸버는 단말에 구현하는 것은 무리수라 보통은 리졸버가 구현된 네임 서버의 IP 주소만을 파악한다. <br>대표적인 것이 KT/LG/SK와 같은 ISP(통신사) DNS가 있고, 브라우저 우회 용도로 많이 쓰는 구글 DNS, 클라우드플레어와 같은 Public DNS 서버가 있다.<br> 그래서 거의 Resolver = Recursive DNS Server = Local Server(of ISP) = Recursor로 생각할 수 있다.


### DNS가 이렇게 구성된 이유
DNS는 너무 많아서 한 개의 컴퓨터 서버로 처리가 불가능. <br>
그렇다면 여러 서버(네임서버)를 만들면 되지 않을까?<br> 그렇게 되면 해당 정보(도메인과 IP 주소)를 모든 서버에서 공유해야한다. 안그러면 어떤 서버(네임서버)에서는 ‘www.hanamon.kr’의 IP 주소를 모른다고 할 수도 있다. <br>
그래서 도메인을 계층적으로 구분하는, 정보(도메인과 IP주소)를 분산하는 구조를 선택하게 되었다.<br>
그래서 도메인에 닷(dot), 점이 있는 것이다. 점이 계층을 나타낸다



### 도메인 네임 스페이스(Domain Name Space)
![alt text](/images/domain_name.webp)
- DNS는 전세계적인 거대한 분산 시스템이다.
- 도메인 네임 스페이스는 이러한 DNS가 저장 관리하는 계층적 구조를 의미한다.
- 도메인 네임 스페이스는 최상위에 루트 DNS 서버가 존재하고 그 하위로 연결된 모든 노드가 연속해서 이어진 계층 구조로 되어있다. (폴더 구조와 비슷하다.)


### 계층적 도메인 레벨(Hierarchical Domain Level)
- 도메인 네임 스페이스의 트리 구조는 최상위 레벨부터 순차적으로 계층적 소속 관계를 나타낸다.
- 하위 조직의 네임 스페이스를 할당하고 관리하는 방식은 각 하위 기관의 관리 책임자에게 위임된다.
- 예를들어 naver.com 도메인은 com 도메인을 관리하는 네임 서버에 등록되어있고 www.naver.com 은 naver.com 을 관리하는 네임 서버에 등록되어있다.
- blog.naver.com을 생성하기 위해서는 naver.com 도메인을 관리하는 네임 서버의 레코드만을 수정함으로써 가능하다.
- 이러한 위임 구조는 호스트의 증가에 대한 관리가 효율적으로 이루어지는 것을 가능하게 한다.
- (그래서 AWS 같은 호스팅에서 구매한 도메인을 사용하려한다면 route53에 생성된 네임서버를 도메인에 추가해야한다. “해당 도메인에 대한 IP 주소를 route53 네임서버에서 찾으시오”같은 것이다. route53에서는 해당 인스턴스나 버킷 등으로 연결되어있다.)

Fully Qualified Domain Name(FQDN) 전체 도메인 이름
도메인의 전체 이름을 표기하는 방식을 말한다.
일반적으로 도메인 이름은 www.naver.com에서 naver.com을 의미하기 때문에 이러한 용어가 나왔다고 본다.
- 도메인 이름: naver.com
- 호스트 이름: www
- FQDN : www.naver.com


### 네임 서버(Name Server = DNS Server)
문자열로 표현된 도메인 이름을 실제 컴퓨터가 통신할 때 사용하는 IP 주소로 변환시키기 위해서는 도메인 네임 스페이스의 트리 구조에 대한 정보가 필요한데 이러한 정보를 가지고 있는 서버를 네임 서버라고 한다. <br>
데이터베이스 역할(저장, 관리), 찾아주는 역할, 요청 처리 응답 구현 전 세계에 13개의 Root DNS 서버가 구축되어 있다. (패킷의 실질적인 크기 제한으로 인해 루트 DNS 서버 수를 13개 서버 주소로 제한하도록 결정되었다고한다.)<br>
그리고 DNS 서버를 복사하여 같은 기능을 담당하는 미러 서버가 있다고 한다.

1. Root DNS 서버<br>
ICANN이 직접 관리하는 절대적인 서버이다.<br>
TLD DNS 서버 IP 주소를 저장하고 안내하는 역할을 한다.
2. Top-Level Domain(TLD) DNS 서버<br>
도메인 등록 기관이 관리하는 서버이다.<br>
Authoritative DNS 서버의 주소를 저장하고 안내하는 역할을 한다.<br>
도메인 판매 업체의 DNS 설정이 변경되면 도메인 등록 기관으로 전달되기 때문에 어떤 도메인이 어떤 판매업체에서 구매했는지 알수 있는 것이다.
3. Second-Level Domain(SLD) DNS 서버 <br>(Authoritative DNS 서버 라고도 함)<br>
실제 개인 도메인과 IP 주소의 관계가 기록(저장, 변경)되는 서버이다.<br>
그래서 권한의 의미인 Authoritative가 붙었다. <br>일반적으로 도메인/호스팅 업체의 네임서버를 말한다.
개인 DNS 구축해도 이 경우에 해당한다.
4. 권한 없는 DNS 서버 (리졸버 서버, 리컬시브 서버, 리커서)<br>
DNS 서버는 도메인 네임 스페이스를 위한 권한 있는 DNS 서버와 권한이 없는 DNS 서버로 구분된다.<br>
위 1,2,3은 권한 있는 DNS 서버이다.<br>
네임 스페이스를 위한 권한 있는 DNS 서버는 IP 주소와 도메인 이름을 매핑한다.<br>
네임 스페이스를 위한 권한 없는 DNS 서버는 질의를 통해 IP 주소를 알아내거나 캐시한다.<br><br>


### 리졸버(Resolver)
- 리졸버는 웹 브라우저와 같은 DNS 클라이언트의 요청을 네임 서버로 전달하고 네임 서버로부터 정보(도메인 이름과 IP 주소)를 받아 클라이언트에게 제공하는 기능을 수행한다.
- 이 과정에서 리졸버는 하나의 네임 서버에게 DNS 요청을 전달하고 해당 서버에 정보가 없으면 다른 네임 서버에게 요청을 보내 정보를 받아온다.
- 이렇듯 리졸버는 수많은 네임서버에 접근하여 사용자로부터 요청 받은 도메인의 IP 정보를 조회하는 기능을 수행한다.
- 하지만 리졸버에 기능을 단말에 구현하는 것은 자원의 한계가 있기에 대부분 기능을 DNS 서버에 구현하고
클라이언트 호스트는 리졸버의 단순한 기능만을 지닌 리졸버 루틴을 구현하는 옵션이 제시되어있다.
- 이러한 단순화된 기능의 리졸버를 스터브 리졸버(Stub Resolver)라고 하며,
스터브 리졸버는 수 많은 네임 서버의 구조를 파악할 필요없이 리졸버가 구현된 DNS 서버의 IP 주소만 파악하면 된다.
- 클라이언트 호스트에서 설정하는 DNS 서버(Recursive DNS Server)는 이와 같은 서버를 의미하는 것으로,
도메인에 대한 질의를 받은 스터브 리졸버는 설정된 DNS 서버로 DNS Query(질의)를 전달하고
DNS 서버로부터 최종 결과를 응답 받아 웹 브라우저로 전달하는 인터페이스 기능만을 수행한다.


### DNS 동작 과정
![alt text](/images/DNS_work.webp)

#### DNS Query(쿼리)란?
DNS 클라이언트와 DNS 서버는 DNS 쿼리를 교환한다.<br>
DNS 쿼리는 Recursive(재귀적) 또는 Iterative(반복적)으로 구분된다. <br>

#### 재귀적 질의(Recursive Query)
결과물(IP 주소)를 돌려주는 작업이다. (결과적으로 Recursive 서버가 Recursive 쿼리를 웹 브라우저 등에게 돌려주는 역할을 한다.) <br>
Recursive 쿼리를 받은 Recursive 서버는 Iterative 하게 권한 있는 네임 서버로 Iterative 쿼리를 보내서 결과적으로 IP 주소를 찾게 되고 해당 결과물을 응답한다.<br>
사전적 의미로써 재귀로, 응답을 돌려주는 쿼리라고 생각하자.<br>

#### 반복적 질의(Iterative Query)
- Recursive DNS 서버가 다른 DNS 서버에게 쿼리를 보내어 응답을 요청하는 작업이다.
- Recursive 서버가 권한 있는 네임 서버들에게 반복적으로 쿼리를 보내서 결과물(IP 주소)를 알아낸다.
- Recursive 서버에 이미 IP 주소가 캐시 되어있다면 이 과정은 건너 뛴다.

ㅇ DNS 질의 종류<br>
- 재귀적 (Recursive Queries, 재귀 질의) <br>
  . 질의된 도메인에 대해 즉각 응답하거나, 다른 서버에게 질의한 결과로 응답하거나, 찾고 있는 정보가 없다는 에러 메시지를 보내줌 <br>
  .. 가장 단순한 DNS 쿼리 유형<br>

- 반복적 (Iterative Queries, 반복 질의)
. 질의된 도메인에 대해 응답하거나, 아니면 이 작업을 할 수 있는 다른 DNS 서버에 클라이언트를 연결 시켜 주는 작업 <br>
.. 자신이 관리하지 않는 알 수 없는 질의에 대해 응답 가능한 네임서버 목록 전달<br>
. 결국, 클라이언트는 다수의 DNS 서버들에게 같은 질의를 반복할 수 있게됨

* 재귀질의 및 반복질의 선택은, DNS 리졸버가, 이를 요청할 때 스스로 선택 결정하여,DNS 헤더 내 플래그 필드에 그 표식을 함



#### DNS 동작 과정 예시
1. 웹 브라우저에 http://google.com을 입력한다
2. 웹 브라우저는 이전에 방문한적 있는지 찾는다.
    - 브라우저 캐시 확인
    - OS 캐시 확인
    - 라우터 캐시 확인
    - ISP 캐시 확인 (Recursive DNS Server)
3. ISP에서 DNS Iterative하게 쿼리를 날린다.
4. ISP는 Authoritative DNS 서버에서 최종적으로 IP 주소를 응답받는다.
5. ISP는 해당 IP 주소를 캐시한다.
6. 웹 브라우저에게 응답한다.

궁금증: 재귀적 쿼리는 리졸버로 클라이언트에서 보내고, 그 후엔 ISP로 반복적 쿼리를 보내는가?



## Public IP(공인 IP)
인터넷 사용자의 로컬 네트워크를 식별하기 위해 ISP(인터넷 서비스 공급자)가 제공하는 IP 주소이다. 공용 IP 주소라고도 불리며 외부에 공개되어 있는 IP 주소이다. <br>
공인 IP는 전세계에서 유일한 IP 주소를 갖는다. <br>
공인 IP 주소가 외부에 공개되어 있기에 인터넷에 연결된 다른 PC로부터의 접근이 가능하다. <br>
따라서 공인 IP 주소를 사용하는 경우에는 방화벽 등의 보안 프로그램을 설치할 필요가 있다.

## Private IP(사설 IP)
일반 가정이나 회사 내 등에 할당된 네트워크의 IP 주소이며, 로컬 IP, 가상 IP라고도 한다.<br>
IPv4의 주소부족으로 인해 서브넷팅된 IP이기 때문에 라우터에 의해 로컬 네트워크상의 PC 나 장치에 할당된다.<br>
사설IP 주소는 다음 3가지 주소대역으로 고정된다.
- Class A : 10.0.0.0 ~ 10.255.255.255
- Class B : 172.16.0.0 ~ 172.31.255.255
- Class C : 192.168.0.0 ~ 192.168.255.255 <br><br>

| |공인 IP|사설 IP|
|---|----|----|
|할당 주체|ISP(인터넷 서비스 공급자)|라우터(공유기)|
|할당 대상|개인 또는 회사의 서버(라우터)|개인 또는 회사의 기기|
|고유성|인터넷 상에서 유일한 주소|하나의 네트워크 안에서 유일|
|공개 여부|내/외부 접근 가능|외부 접근 불가능|

<br>

### nslookup
![alt text](/images/nslookup.png) <br>
Server와 Address 정보는 어느 DNS 서버에 쿼리를 요청했는지를 의미한다. 별도로 DNS 서버를 지정하지 않으면 시스템에서 사용중인 DNS 서버에서 DNS 정보를 조회한다. <br>
Non-authoritative answer은 신뢰할 수 없는 답변이라는 의미이며, 이는 사용자가 이용하는 DNS 서버가 도메인 소유자가 등록한 1차 정보원이 아니기 때문이다. DNS 서버는 상위 DNS 서버에 쿼리를 하고 다시 이를 캐시해서 가지고 있다. 따라서 캐시에 따라서 최신 정보와 다르거나, 혹은 DNS 서버 자체를 신뢰할 수 없는 경우 악의적인 조작을 하는 것도 가능하다.<br>
신뢰할 수 있는 답변을 얻기 위해서는 SOA 레코드를 조회해서 해당 도메인의 정보가 등록되어있는 DNS 서버를 확인하고, 이 서버에 조회를 해보면 된다. <br>
NAME은 조회한 도메인 이름을 의미하며 Address는 google.com에 연결된 IP 주소이다. <br>
![alt text](/images/soa.png) <br>






![alt text](/images/DNS_work.webp)<br>
1. 웹 브라우저에 http://google.com을 입력한다
2. 웹 브라우저는 이전에 방문한적 있는지 찾는다.
    - 브라우저 캐시 확인
    - OS 캐시 확인
    - 라우터 캐시 확인
3. 웹 브라우저는 ISP로 Recursive 쿼리를 날린다.
4. ISP 캐시 확인 (Recursive DNS Server)
5. ISP에서 DNS Iterative하게 쿼리를 날린다. (Root-Top level Domain-Second Level Domain)
6. ISP는 Authoritative DNS 서버에서 최종적으로 IP 주소를 응답받는다.
7. ISP는 해당 IP 주소를 캐시한다.
8. 웹 브라우저에게 응답한다.