---
title:  "리눅스 운영체제 2"
excerpt: "DevOps 부트캠프 Section 1 "

categories:
  - Blog
tags:
  - [Blog, DevOps]

toc: true
toc_sticky: true
 
date: 2023-03-10
last_modified_at: 2023-03-10
---
# 표준스트림?<br>
**표준 스트림은 ‘Standard Stream’** 의 약자로 컴퓨터 프로그램에서 ‘표준적으로’ 입력으로 받고 출력으로 보내는 데이터와 매체를 총칭하는 용어이다. <br>
 프로그램들은 많은 경우 정해진 어떤 ‘입력’을 받으며 많은 경우 정해진 어떤 형태의 ‘출력’을 내놓는다. <br>
 입출력이 전혀 없는 컴퓨터는 우리로써는 효용가치가 없을 것이다. <br>
 과거에는 하드웨어에 입출력이 얽혀있어 다루기 어렵고, 반복작업을 해야하는 일이였다.
 ![alt text](/images/redi.jpg)<br><br>

 표준 스트림에서 표준과 스트림이라는 단어를 나누어서 생각해보자. <br>
먼저 스트림(stream). 스트림은 프로그램을 드나드는 데이터를 바이트의 흐름으로(byte stream) 표현한 단어이다. <br>
유닉스에서는 과거의 입출력을 다루기 어려운 점을 장치를 추상화하여 각 장치를 파일처럼 다루는 방법으로 해결하였다. <br>
다양한 하드웨어 장치들을 파일을 읽고 쓰는 한 가지 작업으로써 다루게 된다. <br>
이 때, 이러한 파일들에서 읽고 나가는 데이터들을 stream 이라고 정의했다. <br><br>

모든 프로그램이 입력과 출력을 필요로 하는데 어떤 프로그램에 있어 만약 대부분의 입력과 출력이 한 출처로부터만 발생한다면 사용자가 명시하지 않는 이상 기본적으로 사용할 입력과 출력을 프로그램 개발 시에 지정할 수 있으면 좋을 것이다. 이렇게 한 프로그램이 기본적으로 사용할 입출력 대상을 ‘표준 입출력’이라고 한다.<br>

‘쉘’은 키보드 입력을 표준 입력으로 하고 모니터 콘솔 출력을 표준 출력으로 한다. 또한 유닉스에서는 따로 명시되지 않는 한 표준 입출력 대상은 부모 프로세스로부터 상속 받는다. 쉘 상에서 ‘ls‘라는 프로그램을 실행하면 이 프로그램은 쉘 프로세스의 자식 프로세스로 실행이 되는데 이때 표준 출력을 상속 받아 쉘과 같은 콘솔에 결과를 반환하는 것이다. <br>

표준 입출력은 표준 입력과 표준 출력으로 나뉘고 표준 출력은 표준 출력와 표준 에러로 나뉜다. 각 프로세스는 초기화될 때 세 가지 스트림이 설정되는데 **표준 출력, 표준 입력, 표준 에러** 이다. <br><br>

## 표준 입력
표준 입력(Standard input)은 프로그램에 입력되는 데이터의 표준적인 출처(장비나 파일)를 일컬으며 stdin 으로 줄여 표현한다. <br>
유닉스 쉘에서는 표준 입력이 키보드로 설정되어 있다.

리눅스에서 표준 입력은 file descriptor(파일을 고유하게 구별하는 식별자) 가 0으로 설정되어 있다. <br><br>

## 표준 출력
표준 출력(Standard output)은 프로그램에서 출력되는 데이터의 표준적인 방향(장비나 파일)을 일컬으며 크게 표준 출력(stdout)과 표준 에러(stderr)로 구분할 수 있다. 유닉스 쉘에서는 표준 출력, 표준 에러 모두 콘솔로 설정되어 있다. <br>

표준 출력은 정상적인 출력이 반환되는 방향을 말하고, 표준 에러는 프로그램의 비정상 종료 시에 반환되는 방향이다. <br>
프로그램이 정상적으로 종료하면 사용자가 바라던 형태의 출력 결과가 나올 것이다. <br>
하지만 실행 시에 어떠한 장애를 만나 비정상적으로 종료하면 보통 에러 메시지를 반환하게 된다. <br>
리눅스에서 표준 출력은 file descriptor가 1로 설정되어 있다. <br>
표준 에러의 file descriptor는 2로 설정되어 있다. <br><br>
[출처](https://shoark7.github.io/programming/knowledge/what-is-standard-stream) : 
https://shoark7.github.io/programming/knowledge/what-is-standard-stream

### 파일 디스크립터(File Disciptor)
리눅스의 모든 파일을 관리하는 방식<br>

명령어 실행 ( 컴퓨터에게 작업을 요청 -> 프로세스 생성 ) <br>

- 실제 프로그램을 실행시키는 작업
- 이러한 프로그램은 파일로 존재
- 파일을 실행 시키기위해서는 먼저 파일을 열어야 한다.
- 파일이 열리면 커널이 해당 프로세스가 동작하는데 필요한장치나 파일을 번호를 붙이며 관리하고, 이러한 번호를 파일 디스크립터 테이블에 저장
- 자주 사용하는 장치들은 미리 번호가 예약되어 있어서 아래와 같이 표현된다.<br><br>

### 파일 디스크립터 테이블
|장치 |번호|설명|
|------|---|---|
|표준 입력장치 (키보드)|0 ( stdin )| 명령어의 표준 입력|
|표준 출력장치 (모니터)|1 ( stdout )|명령어의 표준 출력|
|표준 에러장치 (모니터)|2 ( stderr )|명령어의 표준 오류|


## 리다이렉션 (Redirection)
기본적으로 명령어의 결과는 표준 출력 방식인 모니터에 출력된다. <br>
하지만 리다이렉션을 이용하면 명령의 출력을 변경할 수 있다.<br>
리다이렉션을 이용하여 파일에 기록할 수 있다.<br><br>
기존 파일의 내용을 삭제하고 새로 결과를 저장할 때는 >를,<br>
기존 파일의 내용 뒤에 결과를 추가할 때는 >>를 사용한다.<br>

'< / <<' : 입력 방향 재지정<br>
'> / >>' : 출력 방향 재지정<br>
'>' : 덮어씀<br>
'>>' : 추가됨<br>

![alt text](/images/redi2.jpg)<br><br>

1. 입력 리다이렉션<br>
#[명령어] < [파일]<br>
명령어의 입력(0)으로 파일을 사용
 
- ex) #cat < /etc/resolv.conf      == cat /etc/resolv.conf와 동일
- ex) #nl < /etc/resolv.conf        == nl /etc/resolv.conf와 동일
- ex) #head -3 < /etc/passwd    == head -3 < /etc/passwd와 동일<br><br>


2. **출력 리다이렉션**<br>
#[명령어] > [파일]<br>
화면 (표준 출력장치)에 출력되는 결과를 파일의 내용으로 사용하는 방법 <br>

- #ls -l > result<br>
-> ">기호를 통해 result라는 파일로 리다이렉션하라" 라는 뜻이다. <br>
결과적으로 ls -l 명령의 출력값이 result 파일에 저장된다.<br><br>


3. 추가 리다이렉션<br>
#[명령어] >> [파일]<br>
표준출력장치(1)에 결과를 파일에 추가


4. 오류 리다이렉션<br>
#[명령어] > [파일]<br>
오류 출력은<br>
예를들면, Root가 아닌 일반 사용자로 find 명령어를 사용할 때에는 일반 사용자가 접근 할 수 있는 폴더에서만 파일을 찾게된다.<br>
검색 과정 중 Root만이 들어갈 수 있는 폴더에 접촉할 경우 오류 메세지를 내보내게 된다.<br>
그럴 경우 이것을 다른 파일로 돌려버리면 오류를 제외한 검색 결과만을 볼 수 있게된다.<br><br>

### 파이프
기호 - | (shift + \)<br>
파이프란?<br>
앞 명령어의 결과를 뒤에 나오는 명령어의 입력으로 처리하기 위해 사용하는 방법이다.
<br>
즉, 파이프를 이용하면 명령어를 조합해서 쓸 수 있으며, 서로 다른 프로세스간 작동하는 방식이다.

[출처](https://neul-carpediem.tistory.com/70) : 
https://neul-carpediem.tistory.com/70
<br><br>

### 출력관련 명령어
### cat<br>
cat 명령어는 텍스트로 된 파일일 경우 그 내용을 정상적으로 출력하지만 바이너리 파일일 경우에는 출력은 하지만 알아볼 수 없다. 그리고 2개 이상의 파일이름이 지정되면 모든 파일이 연결되어 보여진다.<br>

사용법 : cat [옵션] 파일명

test 파일을 열어봄
> cat test 

각 행에 번호를 붙여서 출력
> cat -b test 

빈 행에도 번호를 붙임
> cat -n test

연속되는 2개이상의 빈 행을 한행으로 출력
> cat -s test 

<br>

### more <br>
more 명령어는 특정파일의 내용을 확인하는 그 페이지에서 바로 vi 로 파일을 열어서 편집을 할 수도 있으며 텍스트 파일의 내용을 한 페이지씩 차례대로 확인할 수 있다.

사용법 : more 파일명

많은 양의 파일리스트를 확인할때 파이프를 이용해 연결
> more test

특정 파일의 내용을 확인하고 있는 상태에서 사용할 수 있는 키
> ls -l /etc | more

- h : more 명령어상태에서 사용할 수 있는 키 도움말 확인
- Space Bar : 한 화면씩 뒤로 이동하기 (f와 동일)
- Enter : 현재행에서 한 행씩 뒤로 이동하기
- -q : more 명령어 종료하기
- -f : 한 페이지씩 뒤로 이동하기(Space Bar 와 동일)
- -b : 한 페이지씩 앞으로 이동하기
- = : 현재 위치의 행번호 표시하기
- /문자열 : 지정한 문자열을 검색하기
- -n : /문자열로 검색한 문자열을 차례대로 계속해서 찾기
- !쉘명령어 : more 명령어상태에서 쉘명령어를 실행하기
- -v : more 명령어로 열려있는 파일의 현재위치에서 vi를 실행하기

<br>

### less
less는 more와 매우 유사하다.

사용법 : less 파일명

>less test <br>
ls -l | less
less 내부명령키

- Space Bar 또는 f : 한 화면 뒤로 이동
- b : 한 화면 앞으로 이동
- Enter : 한 행씩 뒤로 이동
- 숫자+n : 원하는 페이지만큼 뒤로 이동, 이후부터는 n만 눌러도 숫자페이지만큼 이동
- q : less 수행종료 

<br>

### head 
head는 파일의 앞부분부터 확인하는 명령어이다.

사용법 : head 파일명

기본적으로 행의 앞부분 부터 10 행까지만 출력
> head test 

20행까지 출력
> head -n 20 test 

200 byte 까지의 내용을 출력
> head -c 200 test 

<br>

### tail
tail
tail은 특정파일에 계속 추가되는 모든 내용을 모니터링 할 수 있어 실무에서 유용하게 사용되는 명령어이다.

/var/log/ 디렉토리에 존재하는 많은 시스템로그파일들의 로그파일들에 저장되는 내용들을 실시간으로 계속 모니터링하기 위한 용도로 자주 사용된다.

사용법 : tail 파일명

기본적으로 파일에서 마지막 부분의 10개행을 화면에 출력
> tail test 

마지막 부분의 20개행까지 출력
>tail -n 20 test

마지막에서 200byte 까지를 출력
> tail -c 200 test  

로그파일을 실시간 모니터링, 종료는 Ctrl-c
> tail -f /var/log/messages


## Action action
### wc
wc 명령어는 파일 내의 줄, 단어, 글자 수를 세는데에 사용된다.

> wc myfile.txt

줄의 수를 알고 싶다면 옵션 -ㅣ을 사용
> wc -l myfile.txt

단어의 수를 알고 싶다면 옵션 -w를 사용
> wc -w myfile.txt

글자의 수를 알고 싶다면 옵션 -c를 사용
> wc -c myfile.txt 

<br>

### cut
cut 명령어는 file 이나 표준 입력에서 받은 문자열을 잘라내서 새로운 문자열을 만드는 명령어이다.
예시로써, 파일의 1열부터 3열까지 제거한다면,  
> cut -f 1,3 myfile.txt

- -b, --bytes	바이트를 기준으로 잘라냅니다.	
- -c, --characters	문자열을 기준으로 잘라냅니다.	
- -d, --delimiter	지정한 문자를 구분자로 사용합니다. (기본 TAB)	
- -f, --fields	필드를 기준으로 잘라냅니다.	
- -z, --zero-terminated	라인의 구분자를 개행문자가 아닌 NUL 을 사용합니다.
<br>

### awk
AWK는 유닉스에서 개발된 스크립트 언어로 텍스트가 저장되어 있는 파일을 원하는 대로 필터링하거나 추가해주거나 기타 가공을 통해서 나온 결과를 행과 열로 출력해주는 프로그램. (테이블을 다룬다고 이해함)<br>

### join
두 파일에서 공통의 필드가 있는 행들을 병합한다. join이 정상 동작 하려면 입력 파일들의 행들을 미리 정렬해 두어야 한다.
- -j <필드> : 지정된 필드 번호를 이용해서 병합한다. 필드 번호는 1부터 시작
- -t <문자> : 지정된 문자를 필드 구분 문자로 사용
- --header : 각 파일의 첫 행을 헤더 행으로 사용
<br>

### paste
paste는 여러 텍스트 파일을 수평적으로 join, merge 하는 유닉스 커맨드 라인 유틸리티이다.
- -s 옵션은 수직으로 되어있는 값을 읽어 수평으로 출력
- -d 옵션은 구분자를 지정하여 출력
- -s -d 옵션으로 구분자로 탭(\t)과 개행(\n) 사용하여 출력


### SED
ed명령어와 grep명령어 기능의 일부를 합친 것이 sed(stream editor)명령어이다. <br> sed명령어도 grep명령어와 같은 필터이지만 이 명령어는 파일을 수정할 수 있게 하는 반면 ed처럼 대화식처리는 불가능하다.<br>
sed명령어는 1개 라인씩 입력 라인을 읽어들여 표준출력으로 출력한다.<br>

sed명령어가 ed보다 좋은 점은 라인들을 하나씩 읽고, 수정하고, 출력하기 때문에 기억장치 안의 버퍼를 사용하지 않는다는 것이다. <br>
버퍼를 사용하지 않으면 파일의 크기에 제한 없이 작업을 할 수 있다.<br>
ed와 같이 버퍼를 사용하는 경우는 버퍼의 크기보다 큰 파일은 처리할 수 없으며 대개 버퍼의 크기는 1MB정도이다. <br>
따라서 sed는 아주 큰 파일을 처리할 때 주로 사용된다. <br><br>

### uniq
uniq 는 입력 내용에서 중복된 항목을 제거하는 커맨드 라인 유틸리티이다. <br>
보통 sort 명령어로 정렬을 한 결과를 파이프로 uniq 에 전달해서 중복 내용을 제거한다. <br>
uniq 는 기본적으로 대소문자를 구분하므로 'abc' 와 'AbC' 를 다르게 인식한다. 

- -u 옵션을 사용하면 중복되지 않는 라인만 표시한다. 즉 중복된 line 인 bat 는 표시하지 않는다. 
- -d 옵션을 사용하면 -u 와는 반대로 중복되는 라인만 표시하며 아래 예제는 중복되는 line인 bat 만 표시한다.
- -c 옵션을 사용하면 각 라인별 중복 횟수를 계산해서 표시한다. bat 만 중복되므로 2 가 표시되고 나머지는 다 1이 표시된다. <br>
-c 는 -d 나 -u 옵션과도 같이 사용할 수 있다.
- 대소문자를 무시하는 옵션인 -i, --ignore-case 를 사용하면 'abc' 와 'ABC', 'aBc' 를 모두 같게 처리합니다.<br>

### grep
리눅스에서 grep 명령어는 특정 파일에서 지정한 문자열이나 정규표현식을 포함한 행을 출력해주는 명령어이다. 특히 tail이나 ls 등 다양한 명령어와 조합하여 응용되는 경우가 많아서 이 grep명령어는 리눅스에서 능숙하게 사용할 줄 알아야 하는 기본 명령어이다.

grep 사용법
> grep [옵션][패턴][파일명]

<br>

### 문자열로 찾기<br>
특정 파일에서 'error' 문자열 찾기
> grep 'error' 파일명

여러개의 파일에서 'error' 문자열 찾기
> grep 'error' 파일명1 파일명2

현재 디렉토리내에 있는 모든 파일에서 'error' 문자열 찾기
> grep 'error' *

특정 확장자를 가진 모든 파일에서 'error' 문자열 찾기
> grep 'error' *.log

<br>

### 정규표현식으로 찾기
특정 파일에서 문자열이 포함된 행을 찾는다.
> grep '^[ab]' 파일명 

특정 파일에서 a로 시작하는 모든 단어를 찾는다.
> grep 'a*' 파일명 

특정 파일에서 a로 시작하고 z로 끝나는 5자리 단어를 찾는다.
> grep 'a...z' 파일명 

특정 파일에서 a,b,c로 시작하는 단어를 모두 찾는다.
> grep [a-c] 파일명

특정 파일에서 apple 또는 Apple로 시작하는 단어를 모두 찾는다.
> grep [aA]pple 파일명 

특정 파일에서 a나 b로 시작되는 모든 행을 찾는다.
> grep '^[ab]' 파일명 

특정 파일에서 apple로 시작되고 0나 9의 숫자로 끝나로 시작되는 모든 행을 찾는다.
> grep 'apple'[0-9] 파일명

<br>
자주 사용하는 옵션

- -c : 일치하는 행의 수를 출력한다.
- -i : 대소문자를 구별하지 않는다.
- -v : 일치하지 않는 행만 출력한다.
- -n : 포함된 행의 번호를 함께 출력한다.
- -l : 패턴이 포함된 파일의 이름을 출력한다.
- -w : 단어와 일치하는 행만 출력한다.
- -x : 라인과 일치하는 행만 출력한다.
- -r : 하위 디렉토리를 포함한 모든 파일에서 검색한다.
- -m 숫자 : 최대로 표시될 수 있는 결과를 제한한다.
- -E : 찾을 패턴을 정규 표현식으로 찾는다.
- -F : 찾을 패턴을 문자열로 찾는다.


<br> 

# 시스템 관리자가 하는 일
### 1. 접근 제어 ###
### 2. 업무 자동화 ###
### 3. 재난 대비 ###
### 4. 애플리케이션 배포 및 관리 ###
### 5. 모니터링 ###
### 6. 기타 ###
<br><br><br>

## 1. 접근 제어
운영체제에는 사용자와 관리자가 있다. <br>
사용자는 우리가 일상적으로 사용하는 계정이고, 관리자는 사용자가 접근할 수 없는 영역에 접근할 수 있는 높은 권한을 가지고 있다. <br>
이는 과거 제한 없이 모든 파일에 접근할 수 있을때, 해킹같은 공격에 정보가 탈취당하는 일이 생겨 정보를 보호하기 위해 사용자와 관리자를 구분짓게 되었다.<br><br>
### 리눅스의 사용자 계정 구조도
![alt text](/images/user.png)<br><br>

- /etc/default/useradd	사용자 계정 생성시 필요한 기본정보를 가지고 있는 파일
- /etc/login.defs	새로 생성되는 사용자에 대한 기본 설정파일. 패스워드의 사용기간 만료, 최대 사용기간, 최소 변경기간 등의 패스워드 정책을 설정한다.
- /etc/skel	사용자 계정 생성시 사용자 홈 디렉터리에 구성되는 파일, 디렉터리의 저장소.
- /etc/passwd	사용자 정보가 들어있는 DB                          //백업파일로 /etc/passwd- 파일이 존재
- /etc/shadow	사용자 패스워드 정보가 들어있는 DB             //백업파일로 /etc/shadow- 파일이 존재
- /etc/group	그룹에 대한 정보가 들어있는 DB                  //백업파일로 /etc/group- 파일이 존재
- /etc/gshadow	그룹의 패스워드 정보가 들어있는 DB
- /home/사용자명	사용자의 홈 디렉터리
- /var/spool/mail/사용자명	사용자의 메일 디렉터리

**표준 리눅스 보안(Standard Linux Security)** 은 자유재량 접근 제어(Discretionary Access Controll - DAC) 모델이다.<br> 
DAC 모델에서, 파일과 자원에 대한 결정권은 오직 해당 객체(objects)의 사용자(user id)에 있고 소유권(ownership)에 따라 이뤄진다.<br>
각 사용자와 그 사용자에 의해 실행된 프로그램은 자기에게 할당된 객체에 대해 전적으로 자유재량권을 갖는다. <br>
이러한 상황에서 악의 있는 일반 혹은 루트 사용자 (예로, setuid 와 setgid)가 실행시킨 결함이 있는 소프트웨어를 통해 주어진 객체로 원하는  어떠한 일을 해도 막아낼 방법이 없으며 보안 정책을 시스템 전체에 걸쳐 시행되도록 할 방법이 없다. 


### etc/passwd(사용자 정보)
/etc/passwd에는 시스템에 등록된 사용자의 정보들이 담겨있는 파일이다. <br>
이 파일을 이용해서 사용자의 계정과 인증을 관리하게 된다. <br>
이 파일의 이름이 passwd인데, 여기에 패스워드 정보가 있는건 아니며 과거에 사용자의 패스워드를 이곳에 저장을 하였는데, <br>
/etc/shadow에 따로 암호화된 패스워드를 저장한다. 과거에 패스워드를 저장했었던 것이 아직 파일 이름으로 남아 파일명이 passwd이다.

![alt text](/images/passwd.png)<br><br>
각 필드마다 의미하는 바가 있으며, 각 필드는 콜론(:)으로 구분된다.
> root:x:0:0:root:/root:/bin/bashroot:x:0:0:root:/root:/bin/bash

- 사용자 계정명	맨 앞에 필드는 사용자의 계정명을 나타낸다
- 패스워드	그 다음의 필드는 패스워드 필드인데, x가 의미하는 바는 사용자의 패스워드가 /etc/shadow에 암호화되어 저장되어있다는 뜻이다.
- UID	사용자의 user id를 나타낸다. 관리자 계정(Root)은 UID가 0이다.
- GID	사용자의 그룹 ID를 나타낸다. 관리자 그룹(Root)의 GID는 0이다.
- comment	사용자와 관련한 기타 정보로 일반적으로 사용자의 이름을 나타낸다.
- 홈 디렉토리	사용자의 홈디렉토리를 의미한다. 관리자 계정의 홈 디렉토리는 /root이며, 다른 사용자의 홈 디렉토리는 기본으로 /home/ 하위에 계정명으로 위치한다.
- 로그인 쉘	사용자가 로그인시에 사용할 쉘을 의미한다. 보통 사용자의 쉘은 성능이 우수한 bash쉘을 사용한다. 로그인이 불필요한 계정도 있는데요. 이때는 이 필드가 /usr/sbin/nologin, /bin/false, /sbin/nologin 등으로 표기된다. 이것은 사용자가 아니라 어플리케이션이기 때문이다.
<br><br>

### etc/shadow
/etc/shadow에는 암호화된 패스워드와 패스워드 설정 정책이 기재되어 있다. 여기서 관리자 계정과 관리자 그룹만이 이 파일을 읽을 수 있다. 이 파일이 만약 평문의 비밀번호의 정보를 가지고 있다면 모든 사용자의 비밀번호가 유출될 수 있다.

![alt text](/images/shadow.png)<br><br>

shodow에서도 각 필드마다 의미하는 바가 있으며, 콜론(:)으로 필드가 구분된다. <br>
작성자의 환경에서는 비밀번호가 설정되지 않아 공백이 많은 것을 확인할 수 있다. <br>

다른 예시를 든다면
![alt text](/images/shadow_sample.png)<br><br>

- 사용자 계정명	맨 첫 필드는 사용자의 계정명을 뜻한다.
- 암호화된 패스워드	두번째 필드는 암호화된 패스워드를 뜻한다. 이 패스워드는 또 $로 필드가 구분되어 있으며, 아래처럼 구분이 된다.

$algorithm_id$salt$encrypted_password

algorithm_id : 암호학적 해시의 id를 의미한다. id는 아래와 같다.
1 : MD5(가장 취약한 일방향 해쉬로 요즘에는 쓰지 않는다.
2 : BlowFish
5 : SHA-256
6 : SHA-512
시스템은 SHA-512를 사용하는 것을 알 수 있다.

- salt : 각 해쉬에 첨가할 랜덤값이다. 이 랜덤값에 따라서 해시의 값이 바뀌게 된다.
encrypted_password : 마지막은 알고리즘과 salt로 패스워드를 암호화한 값이다.
이 뿐만 아니라 패스워드 필드에 *, !!, 또는 빈값이 설정될 수 있다.
- '*' : 패스워드가 잠긴 상태이다. 로그인을 할 수 없다. 별도의 인증방식을 사용하여 로그인을 할 수는 있다.
- ! : 패스워드가 잠긴 상태이고 로그인을 할 수 없다. 또는 사용자를 생성하고 패스워드를 설정하지 않은 상태이다.

- empty : 패스워드가 설정되지 않았지만 로그인이 가능다. 

- 마지막 변경	마지막으로 패스워드를 변경한 날을 1970년 1월 1일 기준으로 일수도 표시한다. 여기서 마지막으로 패스워드를 변경한 날은 1970년 1월 1일 이후 18693일이 지났음을 알 수 있다.

- 패스워드 최소 사용기간	패스워드의 최소 사용기간 설정으로 패스워드를 변경한 이후 최소 이 정도의 기간은 써야한다는 것을 의미한다. 그래서 마지막 변경이 일어난 후 이 일수가 지나기 전에 암호를 변경할 수 없다.

- 패스워드 최대 사용기간	패스워드의 최대 사용기간 설정으로 마지막 패스워드 변경 이후 만료일수를 의미한다. 패스워드를 변경하지 않으면 공격자가 패스워드를 깰 수도 있으므로 90일을 권장한다.

- 경고	패스워드 만료 이전에 경고할 경고 일수를 의미한다.

- 비활성화	패스워드가 만료된 이후에 계정이 잠기기 전까지 비활성 일수(date)이다. 해당 비활성 기간동안에 패스워드를 변경해야 계정이 잠기지 않는다. 

- 만료일	계정 만료일 필드이다. 1970년 1월 1일 기준으로 일수로 표시한다. <br><br>

[출처](https://reakwon.tistory.com/137) : 
https://reakwon.tistory.com/137

## root
리눅스나 macOS와 같은 유닉스 계열의 운영체제에서 모든 권한을 가지고 있는 최고 관리자가 사용하는 ID를 의미하며, 최고 관리자인 사람 자체를 가리키기도 한다. <br>
User ID 번호는 0번. 유닉스 계열의 모든 운영체제에는 이 root 유저가 존재한다

### 루트 권한으로만 할 수 있는 작업
- 하드웨어 장치 추가 생성 (장치 파일 생성)
- 시스템 시간 설정
- hostname(네트워크 이름) 설정
- 네트워크 인터페이스 설정
- 1024번 이하의 포트 오픈
- 시스템 종료

## sudo
UNIX 또는 Linux 시스템에서 root는 무한대의 권한을 가지고 있다. <br>
따라서 침입자에게는 root 권한을 얻어내는 것이 최우선이다.<br>
root의 권한은 시스템 관리자, 시스템 커널 자체, 시슽템의 서비스 데몬의 대개 세가지 경우로 한정되어 있다.<br>

su와 비교했을 때 sudo의 장점
- root passwd를 효율적으로 관리할 수 있다.
- root 권한을 사용하는 시간을 최소화하여 안정성을 높인다.
- log 추적이 쉽다.
- 관리의 권한과 책임이 명확하다.
- 일종의 침입탐지 기능을 한다.
[출처](https://deois.tistory.com/entry/sudo%EC%82%AC%EC%9A%A9%EC%9D%98-%ED%95%84%EC%9A%94%EC%84%B1) : 
https://deois.tistory.com/entry/sudo%EC%82%AC%EC%9A%A9%EC%9D%98-%ED%95%84%EC%9A%94%EC%84%B1

단점도 있다.
- sudo 사용자 계정의 보안이 뚫리면, 루트 계정이 뚫린것과 동일
- sudo 명령 로그는 sudo를 통해 지울 수 있다.<br><br>

## 환경변수
환경변수란 프로세스가 컴퓨터에서 동작하는 방식에 영향을 미치는 동적인 값들의 모임이다.
출처: 위키백과

### 리눅스의 환경 변수
명령어 env를 통해 환경변수를 확인할 수 있다.
종류도 매우 많지만, 그중에서 중요한 것은
- SHELL : 로그인해서 사용하는 쉘
- HOME : 사용자의 홈디렉토리
- PATH : 실행파일을 찾는 경로 


### 환경변수 추가
export 명령어를 통해서 쉘 변수를 환경변수로 저장할 수 있다.

> export water

터미널에 위 명령어를 입력하고 env라고 입력하면 환경변수 목록에 water가 추가되었음을 확인할 수 있다. <br>
하지만 이 환경변수는 터미널이 꺼지면 사라지게 된다.<br>

매번 쉘을 실행할 때마다 쉘 변수를 환경변수로 자동으로 설정하고 싶다면 .bashrc 파일에 변수를 저장할 수 있다.<br>
bashrc 경로는 99퍼센트 확률로 홈 디렉토리에 있다. 

찾아가본다면.
vi ~/.bashrc
에 들어가면 환경변수를 설정할 수 있다.

export water="삼다수"
export TEMP_DIR=/tmp
export BASE_DIR=$TEMP_DIR/backup
예를 들어 위와 같이 작성한 후에는 언제 터미널을 실행하더라도 echo $water로 삼다수를 출력할 수 있다. 뿐만 아니라 경로도 동적으로 할당할 수 있다.

### 환경 변수의 필요성
서비스를 운영하는 상황이 달라질때 사용된다.
개발 환경일때, 테스트 환경일때, 실제 운영될 때, 환경 변수로 분리할 수 있다. <br>
다른 예시로는 어떤 중요한 정보(인증 정보 등)이 필요한 경우, 환경 변수를 사용하지 않으면, 소스코드에 직접 입력해야하고 이는 유지보수가 어렵고(정보가 수정된다면? 직접 코드에서 수정)
정보가 노출될 위험이 있다.


### 유저와 그룹의 관계
파일 A가 있을때, 이 디렉토리의 소유권을 가진 유저는 권한을 가진다. <br>
유저와 별개로, 해당 디렉토리의 소유권을 가진 그룹에 속한 유저도 권한을 가진다. 



### 리다이렉션과 파이프 예시
강이 하나 흐르고 있고, 강의 수원을 A지점, 하류를 B지점이라고 설정해보자. <br>
강은 A지점에서 물이 공급되어 B지점으로 나가는 것이 자연적으로 정해져있다. 
이것이 표준 입력과 출력이다. <br>
표준적으로 정해진 입력과 출력이다. <br>
리눅스라면 키보드와 CLI 디스플레이라고 할 수 있을 것이다. 

여기서 A, B 지점 사이에 있는 C 지점에서 수력발전소가 건설되어, 발전을 위해 강물을 C로 끌어가게 되었다.<br>
이것은 리다이렉션이라고 할 수 있다.<br>
B로만 가던 출력을, C지점으로 출력되도록 변경되었다. <br>

C지점에는 발전소가 있으니, 전기가 생산될 것이다. 이러한 전기는 새로운 곳에서 동력으로 사용될 것이다.<br>
이것은 파이프라고 할 수 있다.<br>
발전소에서 출력된 전기가 다른 곳에 입력되어 동력원으로 사용되는 것이다.<br>