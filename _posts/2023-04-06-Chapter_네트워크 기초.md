---
title:  "네트워크 기초"
excerpt: "DevOps 부트캠프 Section 1 "

categories:
  - Blog
tags:
  - [Blog, DevOps]

toc: true
toc_sticky: true
 
date: 2023-04-06
last_modified_at: 2023-04-06
---
# OSI 7계층
![alt text](/images/osi7.png)<br>

국제표준화기구 IOS(International Organization for Standardization)에서는 상호 이질적인 네트워크간의 연결에서 호환성의 결여를 막기위해 OSI(Open Systems Interconnection) 모형을 개발했다.

OSI 7계층을 이용하면 특정 네트워킹 시스템에서 일어나는 일을 계층을 활용해 시각적으로 쉽게 설명할 수 있다.<br>
덕분에 네트워크 관리자는 어떤 문제의 원인이 어디에 있는지 범위를 좁힐 수 있다.<br>
예를 들어 물리적인 문제인지 아니면 응용프로그램과 관련이 있는지 쉽게 파악할 수 있다.<br>
이는 컴퓨터 프로그래머에게도 도움이 된다.<br>
응용프로그램 개발 시 다른 어떤 계층에 작업이 필요한지 쉽게 파악할 수 있기 때문이다.

IT 기업은 고객에게 신제품을 설명할 때 OSI 모형을 많이 활용한다.<br>
해당 제품이 어떤 계층에서 작동하는지 아니면 “스택 전체에 걸쳐” 작동하는지 설명한다.

OSI 모델은 1970년대에 등장한 2가지 별도 모형을 1983년에 합쳐 1984년에 처음 공개됐다.<br>
OSI 모형을 설명할 때 대부분 맨 위 7계층부터 시작해 맨 아래 1계층까지 내려온다.
각 계층과 이들의 의미하는 바는 다음과 같다.<br><br>


### 7계층 – 응용 계층(Application) : User Interface 를 제공하는 계층
응용 계층은 가장 위에 있다. 사용자에게 보이는 부분이다.<br>
OSI 모형에서는 “최종 사용자에게 가장 가까운” 계층이다.<br>
7층에서 작동하는 응용프로그램은 사용자와 직접적으로 상호작용한다.

구글 크롬(Google Chrome), 파이어폭스(Firefox), 사파리(Safari) 등 웹 브라우저와 스카이프(Skype), 아웃룩(Outlook), 오피스(Office) 등의 응용 프로그램이 대표적이다.

- 사용자와 가장 밀접한 계층, 인터페이스(Interface) 역할
- 응용 프로세스 간의 정보 교환 담당 / 전송 단위 : Message
- EX : 전자 메일, 인터넷, 동영상 플레이어 등의 Applicasation

<br>

### 6계층 – 표현 계층(Presentation) : 데이터의 변환 작업을 하는 계층
표현 계층은 응용 계층의 데이터 표현에서 독립적인 부분을 나타낸다.<br>
일반적으로 응용프로그램 형식을 준비 또는 네트워크 형식으로 변환하거나 네트워크 형식을 응용프로그램 형식으로 변환하는 것을 나타낸다. <br>
다시 말해 이 계층은 응용프로그램이나 네트워크를 위해 데이터를 “표현”하는 것이다.<br>
대표적인 예로는 데이터를 안전하게 전송하기 위해 암호화, 복호화하는 것인데, 이 작업이 바로 6계층에서 처리된다.

- 데이터 표현에 차이가 있는 응용처리에서의 제어구조를 제공
※ 데이터 표현에 차이 : ASCII, JPEG, MPEG 등의 번역
- 전송하는 데이터의 인코딩, 디코딩, 암호화, 코드 변환 등을 수행 / 전송 단위 : Message


### 5계층 – 세션 계층(Session) : 응용 프로그램 간의 연결을 지원해주는 계층
2대의 기기, 컴퓨터 또는 서버 간에 “대화”가 필요하면 세션(session)을 만들어야 하는데 이 작업이 여기서 처리된다.<br>
이 계층에는 설정, 조율(예: 시스템의 응답 대기 기간), 세션 마지막에 응용프로그램 간의 종료 등의 기능이 필요하다.

- 통신장치 간 상호작용 및 동기화를 제공
- 연결 세션에서 데이터 교환, 에러 발생 시 복구 관리 => 논리적 연결 담당 / 전송 단위 : Message
- 5계층 장비 : NetBIOS (세션 내 연결관리 및 에러감지, 복구 수행), SSH, Appletalk (Port는 4~5계층 경계 모호)


### 4계층 – 전송 계층(Transport) : 서비스를 구분하고 데이터의 전송 방식을 담당하는 계층 (TCP/UDP)
전송 계층은 최종 시스템 및 호스트 간의 데이터 전송 조율을 담당한다.<br>
보낼 데이터의 용량과 속도, 목적지 등을 처리한다. <br>
전송 계층의 예 중에서 가장 잘 알려진 것이 전송 제어 프로토콜(TCP)이다. <br>
TCP는 인터넷 프로토콜(IP) 위에 구축되는데 흔히 TCP/IP로 알려져 있다.<br>
기기의 IP 주소가 여기서 작동한다.

- 종단 간(End-to-End)에 신뢰성 있고 정확한 데이터 전송을 담당 / 전송 단위 : Segment
- 4계층에서 전송 되는 단위 => 세그먼트(Segment), 종단 간의 에러 복구와 흐름 제어 담당 ex) TCP/UDP
- 4계층 장비 : L4 스위치 (3계층 트래픽 분석, 서비스 종류 구분)


### 3계층 – 네트워크 계층(Network) : 네트워크를 논리적으로 구분하고 연결하는 계층(논리적 주소 사용)
라우터 기능 대부분이 여기 네트워크 계층에 자리잡는다.<br>
가장 기본적으로 볼 때 이 계층은 다른 여러 라우터를 통한 라우팅을 비롯한 패킷 전달을 담당한다.<br>
보스턴에 있는 컴퓨터가 캘리포니아에 있는 서버에 연결하려고 할 때 그 경로는 수백 만 가지다.<br>
이 계층의 라우터가 이 작업을 효율적으로 처리한다.

- 중계 노드를 통하여 전송하는 경우, 어떻게 중계할 것인가를 규정 / 전송 단위 : Packet
- 데이터를 목적지까지 가장 안전하고 빠르게 전달 => 라우팅
- 3계층 장비 : 라우터, L3 스위치


### 2계층 – 데이터 링크 계층(Data Link): 물리적 매체에 패킷 데이터를 실어 보내는 계층 (환경에 맞는 다양한 통신 프로토콜 지원)
데이터 링크 계층은 (두 개의 직접 연결된 노드 사이의) 노드 간 데이터 전송을 제공하며 물리 계층의 오류 수정도 처리한다. <br>
여기에는 2개의 부계층도 존재한다. <br>
하나는 매체 접근 제어(MAC) 계층이고 다른 하나는 논리적 연결 제어(LLC) 계층이다. <br>
네트워킹 세계에서 대부분 스위치는 2계층에서 작동한다.
- 물리적인 연결을 통하여 인접한 두 장치간의 신뢰성 있는 정보 전송을 담당 / 전송 단위 : Frame
- 정보의 오류와 흐름을 관리. 안정된 정보 전달 　　 　　 　　
- 2계층 장비 : 브리지, 스위치


### 1계층 – 물리 계층(Physical) : 신호로 변환하여 전송하는 계층
OSI 밑바닥에는 물리 계층이 있다. <br>
시스템의 전기적, 물리적 표현을 나타낸다.
케이블 종류, (802.11 무선 시스템에서와 같은) 무선 주파수 링크는 물론 핀 배치, 전압, 물리 요건 등이 포함된다.<br>
네트워킹 문제가 발생하면 많은 네트워크 전문가가 물리 계층으로 바로 가서 모든 케이블이 제대로 연결되어 있는지, 라우터나 스위치 또는 컴퓨터에서 전원 플러그가 빠지지 않았는지 확인한다.

- 전기적, 기계적 특성을 이용하여, 통신 케이블로 전기적 신호(에너지)를 전송 / 전송 단위 : bit
- 단지 데이터 전달 역할만을 하고, 알고리즘, 오류 제어 기능 존재 X 　　
- 1계층 장비 : 리피터, 허브, 케이블

[reference](https://velog.io/@ha0kim/TCPIP-%ED%94%84%EB%A1%9C%ED%86%A0%EC%BD%9C-%EB%AA%A8%EB%8D%B8): https://velog.io/@ha0kim/TCPIP-%ED%94%84%EB%A1%9C%ED%86%A0%EC%BD%9C-%EB%AA%A8%EB%8D%B8
<br><br>

# TCP/IP 4계층
국제표준화기구 IOS(International Organization for Standardization)에서는 상호 이질적인 네트워크간의 연결에서 호환성의 결여를 막기위해 OSI(Open Systems Interconnection) 모형을 개발했다.<br>
실제 사용되는 TCP/IP는 OSI 참조 모델을 기반으로 상업적이고 실무적으로 이용될 수 있도록 단순화된 모형이다.<br>
네트워크 전송 시 데이터 표준을 정리한 것이 OSI 7계층, 이 이론을 실제 사용하는 인터넷 표준이 TCP/IP 4계층이다.<br>
OSI 7계층을 4-5계층으로 분류하여 적용할 수 있다.


### L4 응용 계층(Application Layer)
데이터 단위: Data/Message

- 사용자와 가장 가까운 계층으로 사용자가 소프트웨어 application과 소통할 수 있게 해준다.
- 응용프로그램(application)들이 데이터를 교환하기 위해 사용되는 프로토콜
- 사용자 응용프로그램 인터페이스를 담당

예시<br>
파일 전송, 이메일, FTP, HTTP, SSH, Telnet, DNS, SMTP 등


### L3 전송 계층(Transport Layer)
데이터 단위: Segment<br>
전송 주소: Port

- 통신 노드 간의 연결 제어 및 자료 송수신을 담당
- 애플리케이션 계층의 세션과 데이터그램 통신서비스 제공
- 세그먼트 (Segment)단위의 데이타 구성
  - 실질적인 데이터 전송을 위해 데이타를 일정 크기로 나눈 것. 발신, 수신, 포트주소, 오류검출코드가 붙게된다

예시<br>
TCP, UDP, RTP, RTCP 등


### L2 인터넷 계층(Internet Layer)
데이터 단위: 패킷<br>
전송 주소: IP

- 네트워크상 최종 목적지까지 정확하게 연결되도록 연결성을 제공
- 단말을 구분하기위해 논리적인 주소(Logical Address) IP를 할당
  - 출발지와 목적지의 논리적 주소가 담겨있는 IP datagram이라는 패킷으로 데이타를 변경
  - 데이터 전송을 위한 주소 지정
- 라우팅(Routing) 기능을 처리
  - 경로 설정
- 최종 목적지까지 정확하게 연결되도록 연결성 제공
- 패킷단위의 데이타 구성
  - 세그먼트를 목적지까지 전송하기 위해 시작 주소와 목적지의 논리적 주소를 붙인 단위. 데이타 + IP Header

예시<br>
IP, ARP, ICMP, RARP, OSPF


### L1 네트워크 연결 계층(Network Access Layer/Network Interface Layer)
데이터 단위: 프레임<br>
전송 주소: MAC

- 물리적으로 데이타가 네트워크를 통해 어떻게 전송되는지를 정의
  - 논리주소(IP주소 등)이 아닌 물리주소(예. MAC주소(Media Access Control Address))을 참조해 장비간 전송
  - MAC주소란 컴퓨터의 하드웨워 주소
- 기본적으로 에러검출/패킷의 프레임화 담당
- 프레임(Frame)단위의 데이타 구성
  - 최종적으로 데이타 전송을 하기 전 패킷헤더에 MAC주소와 오류 검출을 위한 부분을 첨부

예시<br>
MAC, LAN, 패킷망 등에 사용되는 것
예) Ethernet, PPP, Token Ring 등

[reference](https://velog.io/@jehjong/%EA%B0%9C%EB%B0%9C%EC%9E%90-%EC%9D%B8%ED%84%B0%EB%B7%B0-TCPIP-4%EA%B3%84%EC%B8%B5): https://velog.io/@jehjong/%EA%B0%9C%EB%B0%9C%EC%9E%90-%EC%9D%B8%ED%84%B0%EB%B7%B0-TCPIP-4%EA%B3%84%EC%B8%B5

<br><br>

## HTTP(응용계층)
### 특징
1. 클라이언트 서버 구조<br>
클라이언트가 서버에 요청을 보내면, 서버가 요청에 대한 응답을 보내는 클라이언트-서버 구조로 이루어져 있다.

2. 무상태 프로토콜(Stateless)<br>
HTTP에서는 서버가 클라이언트의 상태를 보존하지 않는다.<br>
따라서 응답과 요청이 독립적이다.

- 장점 : 서버 확장성이 높다.<br>
무상태는 응답 서버를 쉽게 바꿀 수 있기 때문에 무한한 서버 증설이 가능하다.(스케일 아웃)
- 단점 : 클라이언트가 추가 데이터를 전송해야 한다

3. 비연결성(Connectionless)<br>
Connection Oriented(연결을 유지하는 모델)<br>
TCP/IP는 기본적으로 연결을 유지한다.<br>
연결을 유지하는 모델에서는 클라이언트가 요청을 보내지 않더라도 계속 연결을 유지해야 한다.<br>
➡️ 이 경우, 연결을 유지하는 서버의 자원이 계속 소모된다.<br><br>
Connectionless(연결을 유지하지 않는 모델)<br>
비연결성을 가지는 HTTP에서는 실제로 요청을 주고받을 때만 연결을 유지하고 응답을 주고 나면 TCP/IP 연결을 끊는다.<br>
➡️ 이를 통해 최소한의 자원으로 서버를 유지할 수 있다.


### HTTP의 비연결성
HTTP 1.0을 기준으로, HTTP는 기본적으로 연결을 유지하지 않는 모델이다.<br>
일반적으로 초 단위 이하의 빠른 속도로 응답한다.<br>
1시간 동안 수천 명이 서비스를 사용해도 실제 서버에서 처리하는 요청은 수십 개 이하로 매우 작다. (ex. 웹 브라우저에서 연속해서 검색 버튼을 누르지 않기 때문)<br>
비연결성의 특징은 트래픽이 많지 않고, 빠른 응답을 제공할 수 있는 경우 효율적으로 작동한다.<br>
하지만 트래픽이 많고, 큰 규모의 서비스를 운영할 때 비연결성은 한계를 보인다.


### HTTP의 역사
HTTP는 1989년에 Tim Berners-Lee 를 필두로 CERN 기관의 연구자들이 개발하였다. <br>
연구원이다 보니 논문을 읽을 일이 잦았는데, 논문이 단순한 텍스트로 되어 있어 논문에 첨부된 참고 문헌을 일일이 찾아 읽는 것이 번거롭다는 문제가 있었다고 한다. <br>
이러한 문제를 해결하기 위해 문서를 링크로 연결할 수 있는 HTML 이라는 문서 양식을 개발하였고 네트워크를 통해 이 HTML을 주고 받을 수 있도록 고안한 프로토콜이 바로 HTTP 이다. <br>
여담으로, 하이퍼 텍스트라는 개념은 1960년대 부터 있었지만 당시에는 기술의 한계로 이를 구현할 수 없었고 80년대에 인터넷이 발전하면서 비로소 이를 구현할 수 있게 되었다.

### HTTP/0.9
1991년에 나온 최초의 HTTP 명세로, 0.9라는 버전 명은 원래부터 있었던 것은 아니고 이후에 붙여진 것이다. <br>
TCP/IP 위에서 동작하고 기본 포트는 80번을 사용하는, GET 요청만 사용할 수 있는 아주 단순한 프로토콜로서, 클라이언트가 서버에 요청하면 서버는 HTML 형식의 메시지를 응답한 뒤 연결을 종료하는 형태로 동작한다고 명시했다.

HTTP/0.9의 요청 형식은  GET 자원경로↵ 뿐이었으며, 이때 ↵는 캐리지 리턴(optional)과 라인 피드를 나타냅니다:
>GET /page.html↵

또한 요청은 idempotent(즉, 동일한 요청에 대해 항상 동일한 응답을 리턴)한 특성을 가지며, 연결이 종료된 이후에 서버는 요청에 관한 어떠한 정보도 저장하지 말 것을 명시하고 있습니다.<br> 이것이 바로 HTTP가 “stateless”한 프로토콜이라 불리는 이유이다. 그리고 심지어 0.9버전에선 HTTP 헤더조차 존재하지 않았다.<br><br>

### HTTP/1.0
HTTP/0.9가 나온 이후로 수많은 사용자들이 HTTP를 사용했지만, 기능이 매우 제한적이었기 때문에 대부분의 웹 서버들은 0.9버전 스펙에는 명시되지 않은 여러 기능들을 자체적으로 구현하여 사용하고 있었다. <br>
이에 1996년 5월, HTTP Working Group에서 이러한 기능들을 문서화하여 발표하였는데 이것이 바로 HTTP/1.0 이다.<br> 
사실 HTTP/1.0은 새로운 기능을 정의하기보다는, 이미 기존에 사람들이 구현해서 사용하던 기능들을 모아 문서화한 것에 가깝다.

HTTP/1.0에서 추가된 기능을 살펴보면,
- HTTP 헤더가 추가
  - 헤더 이름, 콜론(:), 헤더 값으로 구성되며 헤더 이름은 case-insensitive 입니다.
- HEAD, POST가 추가
  - HEAD는 리소스를 다운받지 않고도 HTTP 헤더와 같은 메타 데이터를 요청할 수 있도록 한 메서드이다.
  - POST는 클라이언트가 서버에게 데이터를 보낼 수 있도록 한 메서드이다. <br>
  FTP와 같은 프로토콜을 통해 서버에 직접 파일을 추가할 필요 없이, POST 메서드를 이용하여 파일을 포함한 여러 데이터를 전송할 수 있게 되었다.
- HTTP 요청에 HTTP/1.0과 같이 HTTP 버전을 명시할 수 있도록 하였다. 하위 호환성을 위해 버전을 명시하지 않으면 0.9버전으로 간주한다.
- HTTP 상태 코드가 추가되었습니다.
  - HTTP/0.9에선 에러를 HTML에 담아 전달했어야 했는데, HTTP/1.0에선 상태 코드를 통해 요청 성공·실패 등의 여부를 명시할 수 있게 되었다. (물론 이외에도 여러 정보를 명시할 수 있다).

HTTP/1.0 요청 및 응답을 예로 들면 아래와 같다:
```
GET /page.html HTTP/1.0↵
Header1: Value1↵
Header2: Value2↵↵


HTTP/1.0 200 OK
Content-Type: text/html

<html>
  <p>Hello, world!</p>
</html>
```
이때, 위에서 볼 수 있듯이 HTTP/1.0 버전의 응답은 HTTP 버전, 상태 코드, 상태 코드 설명으로 구성된다.
<br><br>

### HTTP/1.1
1997년 1월에 최초로 HTTP/1.1 스펙이 공개되었으며, 이후 여러 차례 개정되었다.<br> 
HTTP/0.9 스펙 문서가 약 700자로 구성되었던 것에 비해 HTTP/1.1은 약 100,000자로 1.1버전에 관한 내용을 상세히 다루려면 책 한 권을 써야 할 정도가 되었다.

HTTP/1.1에 추가된 내용을 간략히 살펴보자면,
- HOST 요청 헤더를 반드시 포함하도록 한다.
- 지속 연결 기능이 추가되었다.
- 파이프라이닝 기능이 추가되었다.
- PUT, OPTIONS, DELETE 등의 메서드가 추가되었다.
- 캐시를 제어할 수 있는 메커니즘이 추가되었다.
- HTTP 쿠키가 추가되었습니다.
- 기타 등등…


#### HOST 요청 헤더
HTTP 요청을 보낼 땐 https://www.google.com/index.html과 같은 절대 경로가 아니라 /index.html처럼 상대 경로를 명시한다. <br>
이는 HTTP가 만들어졌을 땐 웹 서버 하나당 오직 하나의 웹 사이트만 호스팅하고 있었기 때문에 굳이 절대 경로를 명시할 필요가 없었기 때문이다. 하지만 최근엔 가상 호스팅(virtual hosting)이라고 해서 하나의 서버에서 여러 개의 도메인을 호스팅할 수도 있다.<br> 
이 때문에 상대 경로뿐만 아니라 어떤 도메인에 접속하는지를 명시해줄 필요가 생겼고, 이전 버전과의 하위 호환성을 위해 절대 경로를 명시하는 방식 대신 HOST 헤더에 도메인을 명시하는 방식으로 구현되었다
```
GET / HTTP/1.1
HOST: www.google.com
```
HTTP/1.1에서 HOST 요청 헤더를 포함하지 않는 경우, 서버는 해당 요청을 무시해야 한다. <br>
물론 대부분의 서버가 HOST 헤더 없이도 알아서 잘 동작하도록 구현되어 있긴 하지만 HTTP/1.1을 사용하는 경우 HOST 헤더를 명시하는 것이 바람직하다.


#### 지속 연결
원래 HTTP는 요청할 때마다 새로운 TCP 연결을 생성하고, 응답을 마치면 연결을 종료하는 방식으로 동작한다. <br>
HTTP로 전송하는 데이터가 많지 않았던 초창기엔 딱히 별문제가 없었지만, 웹이 발전하면서 웹 사이트 하나를 표시하는데 수십,수백 개의 자원을 요청하다 보니 이러한 방식이 문제가 되었다.
![alt text](/images/short_lived_connections.png)<br>

따라서 HTTP/1.1부터는 기존에 연결한 TCP 연결을 재사용하는 지속 연결 기능을 지원한다. (사실 이 기능은 비록 스펙에는 포함되지 않았으나 HTTP/1.0 시절에도 지원하는 서버가 많았다고 한다). <br>
이 기능은 Connection 요청 헤더에 Kee-Alive라는 값을 명시함으로써 사용할 수 있는데, 사실 HTTP/1.1에선 이 기능이 디폴트이기 때문에 굳이 헤더로 명시하지 않아도 기본적으로 지속 연결을 사용한다.

물론, 서버 자원이 무한대가 아니므로 연결을 무한정 유지하는 것은 아니고 timeout을 설정하여 연결된 소켓에 I/O 요청이 마지막에 종료된 시점으로부터 설정한 timeout 시간 동안 연결을 유지한다. <br>
물론 설정한 timeout 이내에 또 다른 요청이 들어오면 계속해서 연결을 유지한다.

이를 그림으로 나타내면 아래와 같다:
![alt text](/images/persistent_connection.png)<br><br>



#### 파이프라이닝
기본적으로 HTTP 요청은 순차적으로 전송되야 한다.<br> 
즉, 이전 요청의 응답을 받은 이후에야 다음번 요청을 보낼 수 있다. <br>
이러한 방식은 네트워크 latency로 인해 지연이 크게 발생할 수도 있다.

이러한 단점을 극복하기 위해, HTTP/1.1에는 하나의 연결을 통해 앞선 요청의 응답을 기다리지 않고 여러 요청을 순차적으로 보낸 다음 요청 순서대로 응답받는(뒤에 보낸 요청에 대한 응답이 먼저 올 수도 있으므로) 파이프라이닝 기술을 도입했다.
![alt text](/images/http_pipelining.png)<br>

하지만 실제로 대부분의 모던 브라우저에선 이러한 파이프라이닝 기술을 사용하지 않는다. 그 이유는

- 이를 제대로 지원하지 않는 프록시 서버가 존재하고, 
- 제대로 구현하기 어렵고,
- 앞선 요청을 기다리지 않고 순차적으로 보낼 수 있긴 하지만 여전히 HOL(Head-of-line blocking)문제가 존재하기 때문이다. <br>
즉, 예를 들어 첫 번째 요청의 응답이 아직 도착하지 않았다면 두 번째 요청의 응답을 내려줄 수 있는 상황임에도 불구하고 첫 번째 요청의 응답이 도착할 때까지 기다려야 하는 문제가 있다.

이러한 문제로 인해 HTTP/1.1의 파이프라이닝 기술은 HTTP/2의 멀티플렉싱 기술로 대체되어 실제로는 거의 사용되지 않는다.<br><br>


### SPRD
HTTP/1.1 까지 존재했던 성능 이슈를 다시 한번 짚어보자면 아래와 같다

- 기본적으로 앞선 요청에 대한 응답이 도착하기 전엔 다음 요청을 보낼 수 없는 HOL 문제가 존재한다. <br>
혹여 파이프라이닝을 도입한다고 하더라도, 이전 요청의 응답이 도착하기 전에 다음 요청을 보낼 수 있게 되지만 응답을 요청 순서에 따라 받아야 하므로 여전히 HOL 문제가 존재한다.<br>
- 응답을 보낸 뒤 연결을 끊기 때문에, 여러 요청을 보내는 경우 매번 TCP handshake, (필요하다면) TLS negotiation, (필요하다면) DNS lookup 과정을 거쳐야 해서 오버헤드가 발생한다.<br>
또한 TCP를 통해 데이터를 전송할 때, 처음에는 데이터를 적게 보내고 점점 보내는 양을 늘려가는 slow start 방식을 사용하기 때문에 이에 따른 성능 저하도 발생한다.
- 이러한 한계점을 보완하기 위해 Keep-Alive 기능을 사용하기도 하고, 또 브라우저에서 한 도메인 당 여러 개의 연결을 생성하여 요청을 병렬로 처리함으로써 HOL 문제 등을 어느 정도 해소하긴 하지만 근본적인 해결책이라고 할 순 없다.

이러한 문제를 근본적으로 해결하기 위해, 2009년 구글에서 SPDY라는 실험용 프로토콜을 개발하였다. <br>
SPDY는 HTTP와는 완전 별개의 프로토콜이 아니라 TLS 위에서 동작하는 프로토콜로, HTTP 요청을 보내면 이를 SPDY 요청으로 변환하여 서버에 날리고, 응답을 다시 HTTP로 변환하는 방식으로 동작한다.

실제 여러 사이트를 대상으로 SPDY를 실험한 결과, 페이지 로딩 속도가 최대 55% 향상되는 성과를 보였다고 한다.<br> 
이후 2010년 가을부터 구글 크롬에서 SPDY를 지원하기 시작했고, 파이어폭스와 오페라는 2012년부터 지원하기 시작했다.

SPDY가 HTTP/1.1 까지 존재했던 한계점을 극복하기 위해 도입한 기술들을 간략히 소개하자면 다음과 같다:

- Multiplexed streams: 하나의 TCP 연결을 통해 여러 요청·응답을 독립적인 스트림으로 묶어 처리한다. <br> 
또한, 한 스트림이 진행 중이더라도 다른 스트림이 끼어드는(interleaving) 것이 가능하다.
- Request prioritization: 각 스트림의 우선순위를 설정하여 우선순위가 낮은 데이터를 전송하는 와중에 우선순위가 높은 데이터가 끼어들어서 더 빨리 전달될 수 있도록 한다.
- Binary protocol: 프레임을 텍스트가 아닌 바이너리로 구성하여 파싱을 더욱 빠르게 하고 오류 발생 가능성을 낮춘다.
- Header compression: 헤더 압축을 통해 요청 데이터의 크기를 더욱 작게 할 수 있다.
- Server push: 서버 푸시를 통해 클라이언트가 요청하지 않은 컨텐츠도 서버가 미리 빠르게 전송하여 RTT를 줄일 수 있다. <br> 
예를 들어, 클라이언트가 서버에 index.html 파일을 요청한 경우 서버에서 CSS 파일도 같이 내려주어 클라이언트가 서버로 보내는 CSS 요청만큼의 시간을 절약할 수 있다.


### HTTP/2
SPDY를 통해 HTTP/1.1에서 존재했던 한계점을 극복할 수 있다는 사실을 확인한 HTTP WG는 SPDY를 기반으로 다음 버전의 HTTP를 만드는 작업에 착수하였으며, 약 2년가량의 작업 끝에 2015년 5월에 RFC 7540 문서로 공식 발표되었다.

HTTP/2의 주목적은 앞서 SPDY에서도 살펴봤듯이 멀티플렉싱 방식을 사용하여 요청·응답을 처리하고, HTTP 헤더 압축을 통해 헤더에 의한 오버헤드를 줄이는 등의 기법을 통해 HTTP/1.1까지 존재했던 HOL과 같은 문제들을 근본적으로 해결하면서 latency를 줄이는 것이다.

[reference](https://jaehyeon48.github.io/network/history-of-http/): https://jaehyeon48.github.io/network/history-of-http/
<br><br>

# IP와 IP Packet
## IP(Internet Protocol)
OSI 참조 모델의 네트워크 계층 기능을 수행하며 패킷 전송을 위한 주소 정의 및 관리와 라우팅을 담당한다.

### IP의 서비스
1. 비신뢰성 : 목저지까지 패킷의 정확한 전송을 보장하지 않는다.
2. 비접속성 : IP는 연결과 관련된 어떠한 상태 정보도 유지하지 않는다.
3. 주소지정 : IP주소를 사용하며, 패킷은 IP주소를 기반으로 목적지까지 전달된다.

### 패킷(Packet)
pack + bucket 합성어로 소포에 비유할 수 있다. <br>
출발지 IP, 도착지 IP 같은 정보가 담겨있다.

### IP패킷의 구성
IP 패킷은 헤더필드와 데이터필드로 나누어진다.<br>
데이터필드에는 TCP, UDP와 같은 상위 계층에서 전달된 PDU가 삽입.<br>
헤더필드에는 패킷을 목적지까지 전송하기 위해 IP계층에서 필요한 값들이 포함.
![alt text](/images/ip_packet.png)<br>
1. 버전(Version)
- IP프로토콜의 버전을 의미. IPv4인지?IPv6인지?
- 4, 6으로 표시

2. 헤더길이(Header Length)
- 옵션 필드를 포함한 헤더의 총 길이
- 옵션이 가변적이기 때문에 최소20byte ~ 최대60byte이다.

3. 서비스타입(Type-Of-Service)
- IP패킷의 우선순위를 결정.

4. 전체길이(Total Length)
- 헤더+데이터를 포함한IP패킷의 전체 길이.
- 바이트단위로 나타낸다

5. 식별자(Identification)
- 패킷을 조립하거나 분해할때 식별하는 번호
- IP에서는 링크의 최대 전달 유닛(MTU : Maximum Transmission Unit)보다 더 큰 데이터를 보내야 하는 경우 여러 개의 작은 패킷으로 분할해서 전송할 수 있다. <br>
분할된 패킷들은 목적지에서 재조립되는데, 동일한 데이터로부터 분할되었음을 인지하고 재조립할 수 있도록 분할된 패킷들을 같은 식별자 필드 값을 갖는다.

6. 플래그(Flag)
- 패킷이 단편화되었는지 아닌지 단서를 제공하는 역할.
- 플래그 필드는 세 비트로 구성..
- 첫번째 비트는 예약된 필드로 사용되지 않는다.
- 두번째 비트는 단편화금지(Don't fragment) 비트로 '1'이면 패킷을 분할할 수 없다.<br>
만약 패킷을 분할해야 하는 경우에 이 비트가 '1'이라면 패킷을 폐기시키고, 송신측으로 ICMP오류 메시지를 보낸다.
- 세번째 비트는 추가단편화(More Fragment)비트로써 이 비트가 '0'이라면 해당 패킷이 분할된 패킷 중 마지막 패킷임을 나타낸다.

7. 단편화 옵셋(Fragment Offset)
- 식별자필드와 플래그필드를 이용하여 패킷을 재조립하기 위해 분할된 패킷간의 순서에 대한 정보를 제공.
- 식별자에서 쪼개진 패킷에 대한 순서정보를 표시

8. Time-To-Live(TTL)
- 패킷이 경유할 수 있는 최대 홉 수.
- 패킷이 라우터를 통과할 때마다 TTL값은 1씩 감소되는데 TTL 값이 0이 되면 패킷은 폐기되고 송신측으로 ICMP메세지가 전달된다.
- if)TTL이 없다면 패킷이 노드상에 계속돌아다니게 된다. 무한loop. <br>
이것을 방지하기 위해 TTL이 있다.

9. 프로토콜(Protocol)
- IP패킷이 어떤 상위 프로토콜과 관련되는지를 나타내기 위해 사용.
- ICMP : 1, TCP : 6, UDP : 17을 의미.
- if)번호가 6번이면 IP헤더를 떼고 트랜스포트계층으로 올려준다.

10. 헤더 체크섬(Header Checksum)
- 오류 발생을 검사하기 위한 필드.

11. 송신자 IP주소(Source Address)
- 출발지 주소를 나타낸다.

12. 수신자 IP주소(Destination Address)
- 목적지 주소를 나타낸다.

[reference](https://m.blog.naver.com/PostView.naver?isHttpsRedirect=true&blogId=jyj9372&logNo=50170030307): https://m.blog.naver.com/PostView.naver?isHttpsRedirect=true&blogId=jyj9372&logNo=50170030307
<br>

IP Packet 한계
- 비연결성
  - 패킷을 받을 대상이 없거나 서비스 불능상태여도 패킷 그대로 전송
- 비신뢰성
  - 전달 중 장애로 인해 패킷이 소실되도 파악할 수 없음
  - 패킷 순서 보장 못함

<br><br>

# TCP와 UDP
## TCP(Transmission Control Protocol)
인터넷상에서 데이터를 메세지의 형태로 보내기 위해 IP와 함께 사용하는 프로토콜

일반적으로 TCP와 IP를 함께 사용하는데, IP가 데이터의 배달을 처리한다면 TCP는 *패킷을 추적 및 관리하게된다.<br> 
TCP는 연결형 서비스를 지원하는 프로토콜로 인터넷 환경에서 기본으로 사용한다.

### TCP의 특징
- 연결 지향 방식이다.
- 3-way handshaking과정을 통해 연결을 설정하고 4-way handshaking을 통해 해제한다.
- 흐름 제어 및 혼잡 제어.
- 높은 신뢰성을 보장한다.
- UDP보다 속도가 느리다.
- 전이중(Full-Duplex), 점대점(Point to Point) 방식.

TCP가 연결 지향 방식이라는 것은 패킷을 전송하기 위한 논리적 경로를 배정한다는 이야기이다. <br>
3-way handshaking과정은 목적지와 수신지를 확실히 하여 정확한 전송을 보장하기 위해서
세션을 수립하는 과정을 의미한다. <br>
TCP가 이러한 특징을 지니는 이유는 TCP는 연결형 서비스로 신뢰성을 보장하기 때문이다. <br>
그래서 3-way handshaking의 과정도 사용하는 것이고, 데이터의 흐름제어나 혼잡 제어와 같은 기능도 한다. <br>
하지만 이러한 기능때문에 UDP보다 속도가 느리다.
(이러한 기능은 CPU를 사용하기 때문에 속도에 영향을 준다.) <br>
그렇기에 TCP는 연속성보다 신뢰성있는 전송이 중요할 때에 사용하는 프로토콜로 예를 들면 파일 전송과 같은 경우에 사용된다.

### TCP 서버의 특징
- 서버소켓은 연결만을 담당한다.
- 연결과정에서 반환된 클라이언트 소켓은 데이터의 송수신에 사용된다
- 서버와 클라이언트는 1대1로 연결된다.
- 스트림 전송으로 전송 데이터의 크기가 무제한이다.
- 패킷에 대한 응답을 해야하기 때문에(시간 지연, CPU 소모) 성능이 낮다.
- Streaming 서비스에 불리하다.(손실된 경우 재전송 요청을 하므로)

<br><br>

## UDP(User Datagram Protocol)
데이터를 데이터그램 단위로 처리하는 프로토콜

데이터그램이란 독립적인 관계를 지니는 패킷이라는 뜻으로, UDP의 동작방식을 설명하자면 다음과 같다.<br>
UDP는 비연결형 프로토콜이다. <br>
즉, 연결을 위해 할당되는 논리적인 경로가 없는데, 그렇기 때문에 각각의 패킷은 다른 경로로 전송되고, 각각의 패킷은 독립적인 관계를 지니게 되며, 데이터를 서로
다른 경로로 독립적으로 처리하게 된다.<br> 
이러한 프로토콜을 UDP라고 한다. 

### UDP의 특징
- 비연결형 서비스로 데이터그램 방식을 제공한다
- 정보를 주고 받을 때 정보를 보내거나 받는다는 신호절차를 거치지 않는다.
- UDP헤더의 CheckSum 필드를 통해 최소한의 오류만 검출한다.
- 신뢰성이 낮다
- TCP보다 속도가 빠르다

UDP는 비연결형 서비스이기 때문에, 연결을 설정하고 해제하는 과정이 존재하지 않는다. <br>
서로 다른 경로로 독립적으로
처리함에도 패킷에 순서를 부여하여 재조립을 하거나 흐름 제어 또는 혼잡 제어와 같은 기능도 처리하지 않기에 TCP보다 속도가 빠르며 네트워크 부하가 적다는 장점이 있지만 신뢰성있는 데이터의 전송을 보장하지는 못합니다. <br>
그렇기 때문애 신뢰성보다는 연속성이 중요한 서비스 <br>
예를 들면 실시간 서비스(streaming)에 자주 사용됩니다.


### UDP 서버의 특징
- UDP에는 연결 자체가 없어서(connect 함수 불필요) 서버 소켓과 클라이언트 소켓의 구분이 없다.
- 소켓 대신 IP를 기반으로 데이터를 전송한다.
- 서버와 클라이언트는 1대1, 1대N, N대M 등으로 연결될 수 있다.
- 데이터그램(메세지) 단위로 전송되며 그 크기는 65535바이트로, 크기가 초과하면 잘라서 보낸다.
- 흐름제어(flow control)가 없어서 패킷이 제대로 전송되었는지, 오류가 없는지 확인할 수 없다.
- 파일 전송과 같은 신뢰성이 필요한 서비스보다 성능이 중요시 되는 경우에 사용된다.

> 흐름제어와 혼잡제어
흐름제어는 데이터를 송신하는 곳과 수신하는 곳의 데이터 처리 속도를 조절하여 수신자의 버퍼 오버플로우를 방지하는 것이다. <br>
예를 들어 송신하는 곳에서 감당이 안되게 데이터를 빠르게 많이 보내면 수신자에서 문제가 발생하기 때문이다.<br>
혼잡제어는 네트워크 내의 패킷 수가 넘치게 증가하지 않도록 방지하는 것이다.<br>
만약 정보의 소통량이 과다하면
패킷을 조금만 전송하여 혼잡 붕괴 현상이 일어나는 것을 막는다.


![alt text](/images/tcptable.png)<br>
 
 [reference](https://mangkyu.tistory.com/15) : https://mangkyu.tistory.com/15

<br><br><br>

# 소켓(socket)
네트워크를 경유하는 프로세스 간 통신의 종착점. <br>
OSI 7계층 중 응용 계층에 속하는 프로세스들은 데이터 송수신을 위해 반드시 소켓을 거쳐 전송 계층으로 데이터를 전달해야한다. <br>
즉, 소켓은 전송 계층과 응용 프로그램 사이의 인터페이스 역할을 하며 떨어져 있는 두 호스트를 연결해준다.
![alt text](/images/socket.png)<br>

소켓은 응용 프로그램에서 TCP/IP를 이용하는 창구 역할을 하며 응용 프로그램과 소켓 사이의 인터페이스를 소켓 인터페이스라고 한다.<br>
소켓을 이용한 네트웍 응용 프로그램에서 상대방과 IP 패킷을 주고받기 위하여는 다음의 다섯 가지 정보가 정해져야 한다.
1. 통신에 사용할 프로토콜(TCP 또는 UDP)
2. 자신의 IP 주소
3. 자신의 포트번호
4. 상대방의 IP 주소
5. 상대방의 포트번호

### 소켓기술자
UNIX에서 파일을 새로 열면(open) int 타입의 정수를 리턴하는데 이와같이 open문이 리턴한 정수를 파일기술자(file descriptor)라고 하며 프로그램에서 open된 파일을 액세스할 때 이 파일기술자를 사용하게 된다.<br>
파일기술자는 기술자 테이블(descriptor table)의 index 번호인데 기술자 테이블이란 현재 open되어 있는 파일의 각종 정보를 포함하고 있는 구조체를 가리키는 포인터들로 구성된 테이블이다.<br>
예를들어 한 응용 프로그램내에서 2개의 파일을 open하면 파일기술자는 3과 4가 배정된다.

프로그램에서 소켓을 개설하면 파일기술자와 똑같은 기능을 하는 소켓기술자(socket descriptor)가 리턴된다.<br>
응용 프로그램에서 이 소켓을 통하여 목적지 호스트와 연결을 요구하거나 패킷을 송수신할 때 해당 소켓기술자를 사용하게 된다<br>
UNIX에서는 파일기술자와 소켓기술자가 같은 기술자 테이블의 index가 된다. 즉, 파일과 소켓이 기술자 테이블을 공유한다.<br>
<br>한 프로세스에서 파일 open시 리턴되는 파일기술자와 소켓 개설시 리턴되는 소켓기술자의 값은 서로 중복된 것이 없게 된다. <br>
소켓기술자의 값은 응용 프로그램내에서 순서대로 배정되며 그 프로그램내에서만 유일하게 구분되면 되는 것이므로 서로 다른 응용 프로그램에서 같은 소켓기술자의 값을 사용하는 것은 문제가 되지 않는다.

<br><br>

### 일반적인 소켓 통신의 흐름
![alt text](/images/sockettrans.png)<br>

#### 서버
1. 소켓 생성
2. 바인딩 (ip, port번호 설정)
3. listen()으로 클라이언트 요청에 대기열을 만들어 몇개의 클라이언트를 대기시킬지 결정
4. accept()로 클라이언트와 연결
5. 데이터 송수신
6. 소켓 닫기

#### 클라이언트
1. 소켓 생성
2. 서버에 설정된 ip, port로 연결 시도
3. accept()로 클라이언트의 socket descriptor 반환
4. 데이터 송수신
5. 소켓 닫기



### 소켓의 종류
(1) 스트림 소켓
- TCP(Transmission Control Protocol)을 사용하는 연결 지향방식의 소켓
- 송수신자의 연결을 보장하여 신뢰성있는 데이터 송수신이 가능
- 데이터의 순서 보장
- 소량의 데이터보다 대량 데이터 전송에 적합
- 점대점 연결

서버
- 소켓 생성
- 바인딩
- listen (연결되지 않은 소켓을 대기모드로 전환)
- 클라이언트 요청 수락 후 통신을 위한 실질적인 소켓 생성 (처음에 생성한 소켓은 새로운 클라이언트 요청을 대기하기 위해 쓰임)
- 데이터 송수신
- 소켓 닫음

클라이언트
- 소켓 생성
- 서버가 설정한 ip, port로 연결
- accept()로 클라이언트의 socket descriptor 반환
- 데이터 송수신
- 소켓 닫음


(2) 데이터그램 소켓
- UDP(User Diagram Protocol)을 사용하는 비연결형 소켓
- 데이터의 순서와 신뢰성을 보장하기 어려움
- 점대점 뿐만아니라 일대다 연결도 가능
- accept 과정없이 소켓 생성 후 바로 데이터 송수신


### HTTP 통신과 소켓 통신의 차이
(1) HTTP 통신<br>
- 클라이언트의 요청이 있을 때만 서버가 응답
- JSON, HTML, Image 등 다양한 데이터를 주고 받을 수 있다.
- 서버가 응답한 후 연결을 바로 종료하는 단방향 통신이지만 Keep Alive 옵션을 주어 일정 시간동안 커넥션을 유지할 수 있다.
- 실시간 연결이 아닌 데이터 전달이 필요한 경우에만 요청을 보내는 상황에 유리

(2) 소켓 통신<br>
- 클라이언트와 서버가 특정 포트를 통해 양방향 통신을 하는 방식
- 데이터 전달 후 연결이 끊어지는 것이 아니라 계속해서 연결을 유지 → HTTP에 비해 더 많은 리소스 소모
- 클라이언트와 서버가 실시간으로 계속하여 데이터를 주고받아야하는 경우에 유리
- 실시간 동영상 스트리밍이나 온라인 게임 등에 사용



## 소켓과 포트의 차이
포트(Port)는, 네트워크를 통해 데이터를 주고받는 프로세스를 식별하기 위해 호스트 내부적으로 프로세스가 할당받는 고유한 값이다. <br>
이 값은 숫자로 표현되기 때문에, 포트 넘버(Port number)라고도 한다. <br>
데이터를 담고 있는 편지봉투에 목적지의 포트가 28080으로 적혀있다면, 목적지 호스트에 도착한 뒤에 해당 호스트에서 28080 포트를 할당받은 프로세스를 찾아서 데이터를 전달해야 한다.

데이터를 보내는 호스트의 프로세스도 반드시 보내기 전에 포트 번호를 할당받아서 보내야 한다. <br>
만약 데이터를 요청하는 호스트가 발신인 불명으로 요청을 보내면 어떻게 될까? 요청받은 호스트의 프로세스가 봉투를 받았는데, 봉투에 발신인이 없다면? <br>
요청한 내용을 처리해서 보내주고 싶어도, 어디로 보내줘야 할지 모른다. <br>
이런 불상사를 막기 위해, 데이터를 보내는 프로세스도 반드시 포트 넘버를 할당받아야 한다. 
​
소켓(Socket)은 네트워크를 경유하는 프로세스 간 통신의 종착점이다. <br>
OSI 7계층 중 응용 계층에 속하는 프로세스들은 데이터 송수신을 위해 반드시 소켓을 거쳐 전송 계층으로 데이터를 전달해야한다. <br>
즉, 소켓은 전송 계층과 응용 프로그램 사이의 인터페이스 역할을 하며 떨어져 있는 두 호스트를 연결해준다.

컴퓨터 세계에서는 프로세스가 데이터를 보내고 싶다고 해서 막 보낼 수 있는 게 아니고, 법칙이 있는데, 바로 보내는 쪽도 받는 쪽도 소켓을 열어야 한다는 점이다. 보내는 쪽이 소켓이라는 창구를 열고 소켓을 통해서 데이터를 보내면 네트워크 모델에 따라 목적지 호스트에 데이터가 도착하게 되고, 데이터를 담은 봉투에 써진 도착지의 포트 넘버와 같은 포트를 할당받은 프로세스를 찾아서, 그 프로세스의 소켓을 통해 해당 프로세스에 데이터를 전달한다.

즉, 포트번호는 내부적으로 프로세스가 할당받는 고유한 값이며, 소켓은 네트워크를 경유하는 프로세스 간 통신의 종착점이다.
소켓은 통신의 엔드포인트로써, IP 주소와 해당 통신의 데이터가 도달해야하는 프로세스의 포트번호의 조합을 의미한다.


## HTTP 버전별 특징과 차이점
HTTP/0.9
- 최초의 HTTP 명세, 원래 있던 버전명은 아니고 이후에 붙여졌다.
- TCP/IP 위에서 동작하고 기본 포트는 80번을 사용하는, GET 요청만 사용할 수 있는 아주 단순한 프로토콜 
- 클라이언트가 서버에 요청하면 서버는 HTML 형식의 메시지를 응답한 뒤 연결을 종료하는 형태로 동작한다고 명시되었다.
- 요청은 idempotent(멱등성 즉, 동일한 요청에 대해 항상 동일한 응답을 리턴)한 특성을 가지며, 연결이 종료된 이후에 서버는 요청에 관한 어떠한 정보도 저장하지 말 것을 명시하고 있다. <br>
=> HTTP가 “stateless”한 프로토콜이라 불리는 이유


HTTP/1.0
- HTTP/0.9가 나온 이후로 수많은 사용자들이 HTTP를 사용했지만, 기능이 매우 제한적이었기 때문에 대부분의 웹 서버들은 0.9버전 스펙에는 명시되지 않은 여러 기능들을 자체적으로 구현하여 사용하고 있었다.
- HTTP/1.0은 새로운 기능을 정의하기보다는, 이미 기존에 사람들이 구현해서 사용하던 기능들을 모아 문서화한 것에 가깝다.
- HTTP 헤더가 추가되었다.
  - 헤더 이름, 콜론(:), 헤더 값으로 구성되며 헤더 이름은 case-insensitive 아다.
- 새로운 메소드 HEAD, POST가 추가되었다.
  - HEAD는 리소스를 다운받지 않고도 HTTP 헤더와 같은 메타 데이터를 요청할 수 있도록 한 메서드이다.
  - POST는 클라이언트가 서버에게 데이터를 보낼 수 있도록 한 메서드이다. <br>
  FTP와 같은 프로토콜을 통해 서버에 직접 파일을 추가할 필요 없이, POST 메서드를 이용하여 파일을 포함한 여러 데이터를 전송할 수 있게 되었습니다.
- HTTP 요청에 HTTP/1.0과 같이 HTTP 버전을 명시할 수 있도록 하였다. <br>
하위 호환성을 위해 버전을 명시하지 않으면 0.9버전으로 간주한다.
- HTTP 상태 코드가 추가되었다.
  - HTTP/0.9에선 에러를 HTML에 담아 전달했어야 했는데, HTTP/1.0에선 상태 코드를 통해 요청 성공·실패 등의 여부를 명시할 수 있게 되었습니다 (물론 이외에도 여러 정보를 명시할 수 있습니다).


HTTP/1.1
HTTP/1.1의 스펙 문서는 약 100,000자로 1.1버전에 관한 내용을 상세히 다루려면 책 한 권을 써야 할 정도이다.

이전 버전에서 추가된 내용은
- HOST 요청 헤더를 반드시 포함하도록 한다.
  - HTTP 요청을 보낼 땐 https://www.google.com/index.html과 같은 절대 경로가 아니라 /index.html처럼 상대 경로를 명시한다. <br>
  이는 HTTP가 만들어졌을 땐 웹 서버 하나당 오직 하나의 웹 사이트만 호스팅하고 있었기 때문에 굳이 절대 경로를 명시할 필요가 없었기 때문이다. <br>
  하지만 요즘엔 가상 호스팅(virtual hosting)이라고 해서 하나의 서버에서 여러 개의 도메인을 호스팅할 수도 있다. <br>
  이 때문에 상대 경로뿐만 아니라 어떤 도메인에 접속하는지를 명시해줄 필요가 생겼고, 이전 버전과의 하위 호환성을 위해 절대 경로를 명시하는 방식 대신 HOST 헤더에 도메인을 명시하는 방식으로 구현되었다. 
- 지속 연결 기능이 추가되었다.(keep-alive)
  - 원래 HTTP는 요청할 때마다 새로운 TCP 연결을 생성하고, 응답을 마치면 연결을 종료하는 방식으로 동작한다. <br>
  HTTP로 전송하는 데이터가 많지 않았던 초창기엔 딱히 별문제가 없었지만, 웹이 발전하면서 웹 사이트 하나를 표시하는데 수십,수백 개의 자원을 요청하다 보니 이러한 방식이 문제가 되었다.<br>
  따라서 HTTP/1.1부터는 기존에 연결한 TCP 연결을 재사용하는 지속 연결 기능을 지원한다. (사실 이 기능은 비록 스펙에는 포함되지 않았으나 HTTP/1.0 시절에도 지원하는 서버가 많았다고 한다). <br>
  이 기능은 Connection 요청 헤더에 Kee-Alive라는 값을 명시함으로써 사용할 수 있는데, 사실 HTTP/1.1에선 이 기능이 디폴트이기 때문에 굳이 헤더로 명시하지 않아도 기본적으로 지속 연결을 사용
- 파이프라이닝 기능이 추가되었다.
  - 기본적으로 HTTP 요청은 순차적으로 전송된다.<br> 
  즉, 이전 요청의 응답을 받은 이후에야 다음번 요청을 보낼 수 있다.<br>
  이러한 방식은 네트워크 latency로 인해 지연이 크게 발생할 수도 있다.<br>
  이러한 단점을 극복하기 위해, HTTP/1.1에는 하나의 연결을 통해 앞선 요청의 응답을 기다리지 않고 여러 요청을 순차적으로 보낸 다음 요청 순서대로 응답받는(뒤에 보낸 요청에 대한 응답이 먼저 올 수도 있으므로) 파이프라이닝 기술을 도입했다.
- PUT, OPTIONS, DELETE 등의 메서드가 추가되었다.
- 캐시를 제어할 수 있는 메커니즘이 추가되었다.
- HTTP 쿠키가 추가되었습니다.
- 기타 등등…


HTTP/2.0
기존 HTTP 1.X 버전의 성능 향상에 초점을 맞춘 프로토콜 <br>
표준의 대체가 아닌 확장 (표준 : HTTP 1.1)

특징
1) HTTP 메시지 전송 방식의 전환<br>
기존 : 일반 텍스트 형식<br>
개선<br>
Binary Framing 계층을 추가해서 보내는 메시지를 프레임(frame)이라는 단위로 분할하며 추가적으로 바이너리로 인코딩을 한다<br>
(바이너리 형식 사용으로 파싱속도 및 전송 속도가 빠르고 오류 발생 가능성이 낮아짐)

2) Multiplexed Streams<br>
기존 : HTTP 1.1의 Pipelining 으로 하나의 커넥션에 여러 요청이 있지만, 결국 동시에 여러 요청을 처리해 응답으로 주지는 못하였음<br>
개선<br>
구성된 연결 내에 전달되는 바이트의 양방향 흐름을 의미하는 Stream으로 요청 / 응답이 교환됨<br>
(하나의 커넥션 안에 여러개의 Stream 존재 가능)<br>
메시지가 이진화된 텍스트인 프레임(frame)으로 나뉘어 요청마다 구분되는 Stream을 통해 전달<br>
즉, 프레임(frame)이 각 요청의 스트림(stream)을 통해 전달되며, 하나의 커넥션 안에 여러개의 스트림(stream)을 가질 수 있게되어 다중화(multiplexing)가 가능해짐<br>
-> 동시에 여러 요청을 처리하는 것이 가능해짐<br>
-> Stream을 통해서 각 요청의 응답의 순서가 의미가 없어져서 HOL Blocking이 자연스럽게 해결됨
3) Stream Prioritization<br>
리소스간 우선순위를 설정하는 기능<br>
Stream에 우선순위를 부여해서 인터리빙되고 전달하는 것이 가능해짐
4) Server Push<br>
단일 클라이언트 요청에 여러 응답을 보낼 수 있는 특징을 통해 Server에서 client에게 필요한 추가적인 리소스를 push해주는 기능
5) Header Compression<br>
기존 : 연속된 요청의 경우 많은 중복된 헤더의 전송으로 오버헤드가 많이발생했음<br>
개선<br>
요청과 응답의 헤더 메타데이터를 압축해서 오버헤드를 감소<br>1. 전송되는 헤더 필드를 static dynamic table로 서버에서 유지<br>2. 이전에 표시된 헤더를 제외한 필드를 허프만(huffman) 인코딩을 수행해서 데이터를 압축


HTTP/3.0
QUIC ?
- Google에서 개발한 UDP 기반의 전송 프로토콜 (Quick UDP Internet Connections)
- Google에서 TCP의 구조적 문제로 성능 향상이 어렵다고 판단하여 UDP 기반을 선택
- QUIC은 TCP의 3-way handshake과정을 최적화 하는 것에 초점을 두고 개발됨
- QUIC은 TCP의 Stream은 하나의 chain으로 연결되는 것과 다르게 각 Stream당 독립된 Stream chain을 구성하여 TCP HOL Blocking을 해결하였다

HTTP 3.0
- QUIC을 기반으로 나온 새로운 HTTP 메이저 버전