---
title:  "지속적 통합"
excerpt: "DevOps 부트캠프 Section 2 "

categories:
  - Blog
tags:
  - [Blog, DevOps]

toc: true
toc_sticky: true
 
date: 2023-04-20
last_modified_at: 2023-04-20
---
# CI/CD 리뷰
전통적인 소프트웨어 전달 방식 : 폭포수(Waterfall) 모델 <br>
출시 시점에 해당 소프트웨어가 완전할 것이라는 보장이 없다. (작업이 완벽하게 된다는 보장?) <br>
소프트웨어의 안정성을 개선하기 위한 베타 버전 테스트 등의 요소를 사용 <br><br>
배포한 버전에서 버그 발생 시 바로 수정하는 것이 불가능함.<br>
다음 버전 배포때까지 버그가 있는 상태로 사용할 수 밖에 없다. <br><br>

이러한 전통적인 소프트웨어에서 개선된 방식이 **SaaS(Software as a Service)** 이다.<br>
서비스로서의 소프트웨어로써, 브라우저에 접속만 해도 새로운 버전을 사용가능.

![alt text](/images/iaas_paas_saas3.webp)
[이미지 출처](https://www.whatap.io/ko/blog/9/): 
https://www.whatap.io/ko/blog/9/ <br><br><br>

**CI/CD (Continuous Integration/Continuous Delivery)** 는 자동화하여 어플리케이션을 더욱 짧은 주기로 고객에게 제공하는 방법입니다.<br>
 CI/CD의 기본 개념은 지속적인 통합, 지속적인 서비스 제공, 지속적인 배포입니다.<br>
  CI/CD는 새로운 코드 통합으로 인해 개발 및 운영팀에 발생하는 문제(일명 "통합 지옥(integration hell)")를 해결하기 위한 솔루션입니다.<br><br>

CI/CD는 애플리케이션의 통합 및 테스트 단계에서부터 제공 및 배포에 이르는 어플리케이션의 라이프사이클 전체에 걸쳐 지속적인 자동화와 지속적인 모니터링을 제공합니다. <br>
이러한 구축 사례를 일반적으로 “CI/CD 파이프라인”이라 부르며, 개발 및 운영팀의 애자일 방식 협력을 통해 DevOps 또는 SRE 방식으로 지원됩니다.<br><br>

**CD(지속적인 제공, Continuous Delivery)** 이란 개발자들이 애플리케이션에 적용한 변경 사항이 버그 테스트를 거쳐 리포지토리(예: GitHub 또는 컨테이너 레지스트리)에 자동으로 업로드되는 것을 뜻하며, 운영팀은 이 리포지토리에서 애플리케이션을 실시간 프로덕션 환경으로 배포할 수 있습니다. <br>
이는 개발팀과 비즈니스팀 간의 가시성 및 커뮤니케이션 부족 문제를 해결해 줍니다. 그러므로 지속적인 서비스 제공은 최소한의 노력으로 새로운 코드를 배포하는 것을 목표로 합니다.<br><br>

**지속적인 배포(또 다른 의미의 "CD": Continuous Deployment)** 란 개발자의 변경 사항을 리포지토리에서 고객이 사용 가능한 프로덕션 환경까지 자동으로 릴리스하는 것을 의미합니다.<br> 이는 애플리케이션 제공 속도를 저해하는 수동 프로세스로 인한 운영팀의 프로세스 과부하 문제를 해결합니다. <br>
지속적인 배포는 파이프라인의 다음 단계를 자동화함으로써 지속적인 서비스 제공의 장점을 활용합니다.

![alt text](/images/CICD.jpg)<br><br>

CI/CD는 지속적인 통합 및 지속적 제공의 구축 사례만을 지칭할 때도 있고, 지속적 통합, 지속적 제공, 지속적 배포라는 3가지 구축 사례 모두 의미하는 것일 수 있다. 즉, "지속적인 서비스 제공"은 때로 지속적인 배포의 과정까지 포함하는 방식으로 사용되기도 한다.<br><br>

즉, **CI(지속적 통합, Continuous Integration)**를 통해 코드 변경 사항을 공유 브랜치 또는 "트렁크"로 다시 병합하는 작업을 수월하게 자주 수행 가능하다.<br>
개발자가 어플리케이션에 적용한 변경 사항이 병합되면 이러한 변경 사항이 어플리케이션을 손상시키지 않도록 자동으로 어플리케이션을 구축, 테스트를 통해 변경사항이 제대로 적용되었는지 확인한다.<br>
클래스와 기능에서부터 전체 어플리케이션을 구성하는 서로 다른 모듈에 이르기까지 모든 것에 대한 테스트를 수행한다.<br>
이러한 테스트에서 코드간의 충돌이 발생하면 CI를 통해 버그들을 더욱 빠르게 자주 수정 가능하다.<br><br>

CI 이후 이어지는 CD(지속적 제공, Continuous Delivery) 프로세스에서는 유효한 코드를 리포지토리에 자동으로 릴리스한다.<br>
효과적인 CD 프로세스를 실현하기 위해서는 개발 파이프라인에는 CI가 먼저 구축되어야한다.<br>
CD의 목표는 프로덕션 환경으로 배포할 준비가 되어 있는 코드베이스를 확보하는 것이다.<br>
CD의 경우 코드 변경 사항 병합부터 프로덕션에 적합한 빌드 제공에 이르는 모든 단계에는 테스트 자동화와 코드 릴리스 자동화가 포함된다.<br><br>

CI/CD 파이프라인의 끝은 CD(지속적 배포, Continuous Deployment)이다.<br>
프로덕션 준비가 완료된 빌드를 코드 리포지토리에 자동으로 릴리스하는 지속적 제공의 <br>
확장된 형태인 지속적 배포는 어플리케이션을 프로덕션으로 릴리스하는 작업을 자동화한다.<br><br><br>

## **지속적 배포 + 지속적 제공 = 지속적 배포** <br><br><br>

### CI/CD 파이프라인을 7 stage로 구성한다면<br>
1.트리거

새 코드가 리포지토리에 커밋되면 파이프라인이 자동으로 트리거된다.<br>
변경사항을 폴링하도록 파이프라인을 구성하거나 해서 파이프라인이 자동으로 실행되도록 한다.



2.코드 체크아웃<br>
CI에서 코드를 체크한다. <br>
CI/CD 툴은 일반적으로 어떤 특정 커밋이 파이프라인을 트리거했는지 알려주는 웹후크나 폴에서 정보를 받는다.<br>
 파이프라인은 지정된 커밋 지점에서 소스 코드를 확인하고 프로세스를 시작한다.



3.코드 컴파일<br>
컴파일된 언어로 개발하는 경우, 컴파일을 실행한다.<br>
CI 툴이 어플리케이션을 컴파일할 때 모든 빌드 도구에 액세스할 수 있어야한다. 예시로 Gradle같은 것들을 예시로 들 수 있다.



4.단위 테스트 실행<br>
CI/CD 파이프라인의 핵심 요소로써 코드베이스에 있는 테스트를 실행하도록 CI/CD 툴을 구성한다.<br>
이 스테이지의 목표는 모든 단위 테스트가 통과했는지 확인하는 것뿐 아니라 코드베이스가 커짐에 따라 테스트가 유지되고 향상되는지 확인해야한다.<br>
어플리케이션이 성장하고 있음에도 테스트가 동일하게 유지되는경우, 테스트되지 않는 코드들이 있음을 의미할 수 있다.



5.코드 패키징<br>
테스트를 통과하면 패키징으로 넘어간다.<br>
어떤 패키징 형식을 선택하든 바이너리를 한 번만 빌드하는 것이 좋다. 안그러면 파이프라인이 복잡해지기 때문이다.



6.승인 테스트 실행<br>
승인 테스트란 소프트웨어가 의도한 바를 수행하고 원래 요구 사항을 충족하는지 확인하는 방법이다.<br>
시간이 많이걸리는 과정이지만, 자동화된 테스트를 수행할 수 있는 방법이 많아지고 있다.



7.배송 또는 배포<br>
어플리케이션이 테스트되면 제공 또는 배포 단계로 이동한다.<br>
이 단계에서는 어플리케이션은 배포할 준비가 되었으며, (여기까지가 지속적인 제공) 혹은 소프트웨어를 자동으로 배포(지속적 배포)할 수 있다.

<br><br><br>

# 유용한 CI 도구
## Jenkins
젠킨스는 소프트웨어 개발 시 지속적으로 통합 서비스를 제공하는 툴이다. <br>
CI(Continuous Integration) 툴 이라고 표현한다.

다수의 개발자들이 하나의 프로그램을 개발할 때 버전 충돌을 방지하기 위해 각자 작업한 내용을 공유영역에 있는 저장소에 빈번히 업로드함으로써 지속적 통합이 가능하도록 해준다.

원래 허드슨 프로젝트로 개발되었고, 허드슨의 개발은 2004년 여름 썬 마이크로시스템즈에서 시작되었다.<br> 그리고 2005년 2월에 java.net에 처음 출시되었다.

젠킨스와 같은 CI툴이 등장하기 전에는 일정시간마다 빌드를 실행하는 방식이 일반적이었다. <br>
특히 개발자들이 당일 작성한 소스들의 커밋이 모두 끝난 심야 시간대에 이러한 빌드가 타이머에 의해 집중적으로 진행되었는데, 이를 nightly-build라 한다. <br>
하지만, 젠킨스는 정기적인 빌드에서 한발 나아가 서브버전, Git 과 같은 버전관리시스템과 연동하여 소스의 커밋을 감지하면 자동적으로 자동화 테스트가 포함된 빌드가 작동되도록 설정할 수 있다.

<br>

### 특징
- 설치형: 별도의 서버가 필요하다.
- 다양한 플러그인을 활용할 수 있다.
- 쿠버네티스, Docker 등과 호환된다.
- 다양한 운영체제에서 사용이 가능하다.

<br>

### 젠킨스의 장점
개발중인 프로젝트에서 커밋은 매우 빈번히 일어나기 때문에 커밋 횟수만큼 빌드를 실행하는 것이 아니라 작업이 큐잉되어 자신이 실행될 차례를 기다리게 된다<br>
코드의 변경과 함께 이뤄지는 이 같은 자동화된 빌드와 테스트 작업들은 다음과 같은 이점들을 가져다 준다.

- 각종 배치 작업의 간략화<br>
프로젝트 기간 중에 개발자들은 순수한 개발 작업 이외에 DB셋업이나 환경설정, Deploy작업과 같은 단순 작업에 시간과 노력을 들이는 경우가 빈번하다. <br>
데이터베이스의 구축, 어플리케이션 서버로의 Deploy, 라이브러리 릴리즈와 같이 이전에 CLI로 실행되던 작업들이 젠킨스 덕분에 웹 인터페이스로 손쉽게 가능해졌다.

- Build 자동화의 확립<br>
빌드 툴의 경우 Java는 maven과 gradle이 자리잡고 있으며, 이미 빌드 관리 툴을 이용해 프로젝트를 진행하고 있다면 젠킨스를 사용하지 않을 이유가 하나도 없다. <br>
젠킨스와 연동하여 빌드 자동화를 통해 프로젝트 진행의 효율성을 높일 수 있다.

- 자동화 테스트<br>
자동화 테스트는 젠킨스를 사용해야 하는 가장 큰 이유 중 하나이며, 사실상 자동화 테스트가 포함되지 않은 빌드는 CI자체가 불가능하다고 봐도 무방하다. <br>
젠킨스는 Subversion이나 Git과 같은 버전관리시스템과 연동하여 코드 변경을 감지하고 자동화 테스트를 수행하기 때문에 만약 개인이 미처 실시하지 못한 테스트가 있다 하여도 든든한 안전망이 되어준다. <br>
제대로 테스트를 거치지 않은 코드를 커밋하게 되면 화난 젠킨스를 만나게 된다.

- 코드 표준 준수여부 검사<br>
자동화 테스트와 마찬가지로 개인이 미처 실시하지 못한 코드 표준 준수 여부의 검사나 정적 분석을 통한 코드 품질 검사를 빌드 내부에서 수행함으로써 기술적 부채의 감소에도 크게 기여한다.

- 빌드 파이프라인 구성<br>
2개 이상의 모듈로 구성되는 레이어드 아키텍처가 적용 된 프로젝트에는 그에 따는 빌드 파이프라인 구성이 필요하다. <br>
예를 들면, 도메인 -> 서비스 -> UI와 같이 각 레이어의 참조 관계에 따라 순차적으로 빌드를 진행하지 않으면 안된다. <br>
젠킨스에서는 이러한 빌드 파이프라인의 구성을 간단히 할 수 있으며, 스크립트를 통해서 매우 복잡한 제어까지도 가능하다.

<br>

### 젠킨스 단점
규모가 작은 프로젝트의 경우, 설정하는데 리소스 낭비가 발생할 수 있다.
호스팅을 직접해야하기 때문에 서버 운영 및 관리 비용이 발생한다.

[reference](https://ict-nroo.tistory.com/31)

<br><br>

## Travis CI
Travis CI는 오픈 소스 프로젝트와 프라이빗 프로젝트의 지속적인 통합 및 배포(CI/CD) 서비스이다.

GitHub, Bitbucket, GitLab 등과 같은 버전 관리 시스템과 연동하여 특정 이벤트(커밋, 풀 리퀘스트 등) 발생 시 지정된 작업(테스트, 빌드, 배포 등)을 수행하도록 설정할 수 있다.

또한 Travis CI는 많은 프로그래밍 언어와 프레임워크를 지원합니다. 각각의 프로젝트마다 .travis.yml 파일을 생성하여 언어, 빌드 환경, 테스트 및 배포 설정 등을 정의할 수 있다.

이를 통해, 개발자는 자동화된 빌드, 테스트, 배포 과정을 간편하게 수행할 수 있으며, 이를 통해 개발자는 더욱 안정적인 코드를 배포할 수 있다.

<br>

### 특징
- 클라우드 서비스(SasS) 형태로 사용할 수 있다.
- Travis 자체에서 호스팅을 해주기 때문에 관리적인 측면에서 편리하다.
- Clojure, Erlang, Groovy Haskell, Java, JavaScirpt, Node.js, Perl PHP, Rython, Ruby 등의 다양한 언어를 지원한다.

<br><br>

## GitHub Actions
GitHub Actions는 코드 저장소(repository)로 유명한 GitHub에서 제공하는 CI(Continuous Integration, 지속 통합)와 CD(Continuous Deployment, 지속 배포)를 위한 비교적 최근에 추가된 서비스이다. <br>
GitHub에서 코드를 관리하고 있는 소프트웨어 프로젝트에서 사용할 수 있으며 개인은 누구나 GitHub에서 코드 저장소를 무료로 만들 수 있기 때문에 다른 CI/CD 서비스 대비 진입장벽이 낮은 편이다.

GitHub Actions를 사용하면 자동으로 코드 저장소에서 어떤 이벤트(event)가 발생했을 때 특정 작업이 일어나게 하거나 주기적으로 어떤 작업들을 반복해서 실행시킬 수도 있다. <br>
예를 들어, 누군가가 코드 저장소에 Pull Request를 생성하게 되면 GitHub Actions를 통해 해당 코드 변경분에 문제가 없는지 각종 검사를 진행할 수 있다. <br>
어떤 새로운 코드가 메인(main) 브랜치에 유입(push)되면 GitHub Actions를 통해 소프트웨어를 빌드(build)하고 상용 서버에 배포(deploy)할 수도 있습니다. <br>
뿐만 아니라 매일 밤 특정 시각에 그날 하루에 대한 통계 데이터를 수집시킬 수도 있습니다.

이렇게 소프트웨어 프로젝트에서 지속적으로 수행해야하는 반복 작업들을 업계에서는 소위 CI/CD라고 많이 줄여서 부른다. <br>
사람이 매번 직접 하기에는 비효율적인데다가 실수할 위험도 있기 때문에 GitHub Actions와 같은 자동화시키는 것이 유리하다.

GitHub Actions는 기존 CI/CD 서비스 대비 간편한 설정과 높은 접근성으로 특히 개발자들 사이에서 많은 호응을 얻고 있다. <br>
예전에는 CI/CD가 DevOps 엔지니어의 전유물로만 여겨지곤 했었는데 최근에는 GitHub Actions을 통해서 일반 개발자들도 어렵지 않게 CI/CD 설정을 스스로 할 수 있다.

### Workflows
GitHub Actions에서 가장 상위 개념인 워크플로우(Workflow, 작업 흐름)는 쉽게 말해 자동화해놓은 작업 과정이라고 볼 수 있다. <br>
워크플로우는 코드 저장소 내에서 .github/workflows 폴더 아래에 위치한 YAML 파일로 설정하며, 하나의 코드 저장소에는 여러 개의 워크플로우, 즉 여러 개의 YAML 파일을 생성할 수 있다.

이 워크플로우 YAML 파일에는 크게 2가지를 정의해야하는데요. 첫번째는 on 속성을 통해서 해당 워크플로우가 언제 실행되는지를 정의합니다.

두번째는 jobs 속성을 통해서 해당 워크플로우가 구체적으로 어떤 일을 해야하는지 명시해야한다.

예를 들어, 코드 저장소의 main 브랜치에 push 이벤트가 발생할 때 마다 워크플로우를 실행하려면 다음과 같이 설정해줍니다.

```
on:
  push:
    branches:
      - main

jobs:
  # ...(생략)...
```


### Jobs
GitHub Actions에서 작업(Job)이란 독립된 가상 머신(machine) 또는 컨테이너(container)에서 돌아가는 하나의 처리 단위를 의미한다.<br> 하나의 워크플로우는 여러 개의 작업으로 구성되며 적어도 하나의 작업은 있어야 한다. (아니라면 실행할 작업이 없으니 워크플로우가 의미가 없겠죠?) <br>
그리고 모든 작업은 기본적으로 동시에 실행되며 필요 시 작업 간에 의존 관계를 설정하여 작업이 실행되는 순서를 제어할 수도 있다.

작업은 워크플로우 YAML 파일 내에서 jobs 속성을 사용하며 작업 식별자(ID)와 작업 세부 내용 간의 맵핑(mapping) 형태로 명시된다.

예를 들어, job1, job2, job3이라는 작업 ID를 가진 3개의 작업을 추가하려면 다음과 같이 설정한다.

```
jobs:
  job1:
    # job1에 대한 세부 내용
  job2:
    # job2에 대한 세부 내용
  job3:
    # job3에 대한 세부 내용
```
작업의 세부 내용으로는 여러 가지 내용을 명시할 수 있다. <br>
필수로 들어거야 하는 runs-on 속성을 통해 해당 리눅스나 윈도우즈와 같은 실행 환경을 지정해줘야 합니다.

예를 들어, 가장 널리 사용되는 우분투의 최신 실행 환경에서 해당 작업을 실행하고 싶다면 다음과 같이 설정한다.

```
jobs:
  job1:
    runs-on: ubuntu-latest
    steps:
      # ...(생략)...
```
작업에서 가장 중요한 부분은 작업 순서를 정의하는 것이라 할 수 있는데, 이 부분은 steps 속성을 통해서 설정을 할 수 있다.

<br>

## Steps
정말 단순한 작업이 아닌 이상 하나의 작업은 일반적으로 여러 단계의 명령을 순차적으로 실행하는 경우가 많죠?<br> 그래서 GitHub Actions에서는 각 작업(job)이 하나 이상의 단계(step)로 모델링이 된다.

작업 단계는 단순한 커맨드(command)나 스크립트(script)가 될 수도 있고 다음 섹션에서 자세히 설명할 액션(action)이라고 하는 좀 더 복잡한 명령일 수도 있다. <br>
커맨드나 스크립트를 실행할 때는 run 속성을 사용하며, 액션을 사용할 때는 uses 속성을 사용한다.

예를 들어 자바스크립트 프로젝트에서 테스트를 돌리려면 코드 저장소에 코드를 작업 실행 환경으로 내려 받고, 패키지를 설치한 후, 테스트 스크립트를 실행해야할 것이다. <br>
이 3단계의 작업은 아래와 같이 steps 속성을 통해서 명시될 수 있다.

```
jobs:
  test:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v3
      - run: npm install
      - run: npm test
```

워크플로우 파일 내에서 작업 단계를 명시해줄 때는 주의할 부분이 있다.<br> 
YAML 문법에서 시퀀스(sequence) 타입을 사용하기 때문에 각 단계 앞에 반드시 -를 붙여줘야 한다.

<br>

## Actions
액션은 GitHub Actions에서 빈번하게 필요한 반복 단계를 재사용하기 용이하도록 제공되는 일종의 작업 공유 메커니즘이다. <br>
이 액션은 하나의 코드 저장소 범위 내에서 여러 워크플로우 간에서 공유를 할 수 있을 뿐만 아니라, 공개 코드 저장소를 통해 액션을 공유하면 GitHub 상의 모든 코드 저장소에서 사용이 가능해진다.

GitHub에서 제공하는 대표적인 공개 액션으로 바로 위 예제에서도 사용했던 체크 아웃 액션(actions/checkout)을 들 수 있다. <br>
대부분의 CI/CD 작업은 코드 저장소로 부터 코드를 작업 실행 환경으로 내려받는 것으로 시작하므로 이 액션은 매우 범용적으로 사용된다.

## 정리
워크플로우(workflow)는 자동화 시켜놓은 작업 과정을 뜻하며 YAML 파일을 통해 어떤 작업(job)들이 언제 실행되야 하는지를 설정한다.

각 워크플로우는 독립된 환경에서 실행되는 작업(job)이 적어도 한 개 이상으로 구성되며, 각 작업에는 작업 ID가 부여되고 세부 내용(실행 환경, 작업 단계 등)이 명시된다.

하나의 작업은 보통 순차적으로 수행되는 여러 개의 단계(step)로 정의되며, 각 단계는 단순한 커맨드(command)일 수도 있고 추상화된 액션(action)일 수도 있다.

[reference](https://www.daleseo.com/github-actions-basics/): https://www.daleseo.com/github-actions-basics/


### GitHub Action이 다른 CI 도구에 비해 갖는 장점
통합성: GitHub Action은 GitHub와 완전히 통합되어 있으며, 리포지토리 내에서 바로 사용할 수 있습니다. 이는 다른 CI 도구에 비해 통합이 간편하다는 의미입니다.

무료 사용: GitHub Action은 GitHub에서 무료로 제공하는 서비스이며, 사용한 만큼 요금이 부과되지 않습니다.

다양한 액션 라이브러리: GitHub Action은 다양한 액션 라이브러리를 제공하며, 이를 통해 다양한 빌드, 테스트, 배포 등의 작업을 손쉽게 수행할 수 있습니다.

커뮤니티: GitHub Action은 GitHub과 같이 큰 커뮤니티를 갖고 있습니다. 이를 통해 다른 사용자들이 만든 액션을 공유하거나, 문제를 해결하는 데 도움을 받을 수 있습니다.

자체 환경: GitHub Action은 사용자가 직접 환경을 설정할 수 있어, 다른 CI 도구에 비해 더욱 유연하게 사용할 수 있습니다.

시각화: GitHub Action은 GitHub의 웹 인터페이스를 통해 빌드 및 배포 프로세스를 시각화할 수 있어, 이해하기 쉽고 직관적입니다

reference: ChatGPT



# 빌드와 언어별 빌드 도구
## 빌드
빌드는 컴파일(Compile)과 링크(Link)를 합쳐서 부르는 용어이다.

컴파일이란 작성한 소스 코드를 컴퓨터가 이해할 수 있는 기계어로 변환하는 작업을 가리키는 용어이다.<br>
이 작업을 수행하는 프로그램을 컴파일러라고 부른다. <br>
사람으로 비유하자면 통역가라고 할 수 있다. <br>
일반적으로 컴파일의 결과는 .exe 파일로 나타나는데, 어셈블리어로 작성한 asm 파일의 경우에는 컴파일의 결과가 exe 파일이 아닌 obj 파일이다.

obj 파일들을 연결해서 하나의 exe 파일을 만드는 작업을 링크라고 부르고, 이 동작을 수행하는 프로그램을 링커라고 한다.

![alt text](/images/build.png)

이렇게 각각의 컴파일과 링크 작업으로 생성되는 최종 exe 파일의 생성 작업을 통칭해서 빌드라고 한다.

[reference](https://datalibrary.tistory.com/23): https://datalibrary.tistory.com/23

<br>

## 라이브러리
Gof의 디자인 패턴으로 유명한 랄프 존슨(Ralph Johnson)은 "프레임워크란, 소프트웨어의 구체적인 부분에 해당하는 설계와 구현을 재사용이 가능하게끔 일련의 협업화된 형태로 클래스들을 제공하는 것"이라고 정의하였다.


## 프레임워크 vs 라이브러리
라이브러리란 자주 사용되는 로직을 재사용하기 편리하도록 잘 정리한 일련의 코드들의 집합을 의미합니다. (참고: 생활코딩)

생활코딩에서 정의한 라이브러리 내용은 어느 정도 이해가 가지만 저명한 전문가가 Framework를 정의한 것은 이해하기가 쉽지 않다. <br>
또한 위의 정의만으로 두 개념 사이의 차이도 명확하지 않다.

프레임워크는 자동차의 프레임, 즉 기본적으로 구성하고 있는 뼈대를 말한다.<br>
라이브러리는 자동차의 기능을 하는 부품을 의미한다.

이 때, 예시로 한 번 정해진 자동차의 프레임은 바꾸질 못한다.<br>
소형차를 만들기 위해 뼈대를 사용하는데, 이 뼈대로 SUV를 만들 수는 없다.<br>
그러나 바퀴나, 선루프, 헤드라이트 등은 비교적 다른 종류로 쉽게 바뀔 수 있을 것이다.

사실 자동차를 만들기 위해서 자동차의 프레임과 부품들을 가져다 쓰지 않아도 된다.<br>
프레임을 일일이 만들고, 부품을 일일이 만들어서 자동차를 만들어도 된다.<br>
그러나 너무 많은 시간과 비용이 들게 될 것이다.<br>
그래서 프레임워크와 라이브러리가 존재한다.

내가 정말로 원하는 기능을 구현하기 위해 기본적인 뼈대와 부품을 가져다 쓰겠다는 이야기이다.<br>


### 프레임워크 종류
- 자바 프레임워크<br>
Struts, Spring, 전자정부 프레임워크 

- QRM 프레임워크<br>
myBatis(iBatis), Hibernate 

- 자바스크립트 프레임워크<br>
AngularJS, React, Polymer, Ember 

- 프론트엔드 프레임워크 <br>
Bootstrap, Foundation, MDL 


### 프레임워크 장단점
장점
1) 효율적
- 아무것도 그려지지 않은 제로에서 코드를 일일이 짜는 것보다 시간과 비용이 훨씬 절약되며 생산성이 좋아진다.

2) Quality 향상
- 버그 발생 가능성을 처리해줌으로써 개발자가 반복 작업에서 실수하기 쉬운 부분을 커버해준다. <br>
다수의 개발자가 사용하며 수정하다 보니 이미 검증된 코드라고 볼 수 있다.

3) 유지 보수에 용이
- 프레임워크를 쓰지 않고 일일이 코드를 짜 놓은 경우, 회사 입장에서 개발 담당자가 바뀌어버리면 곤란할 것이다. <br>
그러나 Framework를 사용하면 코드가 보다 체계적이어서 담당자가 바뀌더라도 위험부담을 줄일 수 있으며 유지 보수에 안정적이다.


단점
1) 학습시간이 길다.
- 코드를 본인이 짜 놓은 것이 아니기 때문에, 프레임워크에 있는 코드를 습득하고 이해하는 데 오랜 시간이 걸린다.


2) 제작자의 의도된 제약 사항
- 제작자가 설계한 구조를 어느 정도 유지한 채 코드에 살을 붙여나가야 한다. <br>
따라서 개발자는 자유롭고 유연하게 개발하는 데 한계가 있다.

[reference](https://moolgogiheart.tistory.com/87): https://moolgogiheart.tistory.com/87

<br>

## 대표적인 빌드 도구
### JavaScript 기반의 React 생태계
React 프레임워크를 사용하는 경우 create-react-app 또는 next.js 와 같은 프레임워크를 사용한다. 
이 경우 대부분 다음과 같은 과정으로 프로덕션용 빌드 결과물(아티팩트)을 만들어낼 수 있다.

1. node.js 개발 환경 준비
2. 프로젝트 폴더로 이동
    - package.json 파일이 있는지 확인합니다
3. 의존성 (dependency) 설치
    - npm install 명령 입력
4. 빌드
    - npm run build 명령 입력
5. 빌드 결과물 확인
    - build 폴더 확인
    - React는 프론트엔드 웹 애플리케이션이므로 결과물로는 HTML, CSS, JS 파일을 포함한다.
    - 이후 이 파일들을 nginx 등에서 정적 호스팅할 수 있다.

의존성 설치 후 빌드하지 않고, 바로 애플리케이션을 실행하기 위해서는 npm run start 등의 명령어를 사용할 수 있다. <br>
마찬가지로, 애플리케이션에 단위 테스트가 제공된다면, 애플리케이션의 테스트를 위해 npm run test 명령어를 사용한다. <br>
각 프로젝트에서 사용하는 package.json 파일이 어떻게 구성되어 있느냐에 따라 달라질 수 있다.

### Java/Kotlin 기반의 Spring Boot 생태계 (Gradle)
Java/Kotlin 애플리케이션을 빌드하면 JVM(자바 런타임) 위에서 실행되는 war 파일이 아티팩트로 생성된다. <br>
빌드 도구를 이용해 이를 실행할 수도 있다. <br>
Spring 및 Spring Boot 생태계에서는 대표적인 빌드 도구가 두 가지(maven, Gradle)가 있다. <br>


1. 자바 개발 환경(JDK, OpenJDK가 대표적) 준비
2. gradle 설치
3. 프로젝트 폴더로 이동
4. 빌드
    - gradlew build 명령 입력

자바 애플리케이션은 실행을 위해서 빌드가 필수적이다.<br> 
따라서, 빌드 후에 실행을 위해서 gradlew bootRun 명령을 통해 애플리케이션의 실행이 가능하다.<br> 그밖에 gradle tasks를 이용해 gradle에서 사용할 수 있는 다양한 태스크를 확인할 수 있다.


### 빌드가 필요 없는 경우
node.js 앱이나 Python과 같이 소스 코드 그대로 런타임을 실행할 수 있는 경우, 즉 다른 변환 작업이 필요 없는 경우에는 빌드 과정이 생략될 수 있다.

<br><br><br>

# 지속적 통합
Continuous Intergration
지속적 통합은 기존에 있던 기능과 새로운 기능의 통합을 의미한다.<br>
(CI tool: CI를 자동화 해주는 소프트웨어)

<br>

## 얻을 수 있는 장점
- 버그를 일찍 발견할 수 있다.
- 빌드 및 테스트와 같이 사람이 해야 할 일들을 자동화할 수 있다.
- 테스트가 완료된 코드에 대해 빠른 전달이 가능하다.
- 지속적인 배포가 가능해진다.
- 개발자의 생산성을 향상시킬 수 있다.

<br>

## 테스트 과정의 중요성
- 테스트를 통해 결함과 버그를 조기에 발견 할 수 있으며, 이는 개발자의 생산성을 향상할 수 있다.
- 제품의 결함과 버그를 발견하고 수정하는 것은 소프트웨어의 품질을 보증하고, 더 안정적이고 사용하기 쉽게 만든다.

<br>

## 지속적 통합에 대한 정의와 원칙
팀 구성원이 각자의 작업을 자주 통합하는 소프트웨어 개발 방식 - Martin Fowler

1. 레파지토리 단일화<br>
- 프로젝트에서 제품을 빌드하기 위해 함께 조정해야 하는 수많은 파일이 포함되어 있기 때문이다.
- 이 모든 파일이 단일 소스 레파지토리가 아닌 곳에 뿔뿔이 흩어져 있다면 추적하는 것이 굉장히 힘들어질 것이다.

2. 빌드 자동화<br>
- 빌드가 수동으로 진행된다면, 수 많은 실수를 낳을 수 있다.

3. 셀프 테스팅 빌드<br>
- 빌드 프로세스에 자동화된 테스트를 포함 함으로써 버그를 더 빠르고 효율적으로 파악할 수 있다.<br>
- 지속적 통합의 일부인 테스트 주도 개발(TDD)을 통해 손상된 빌드를 즉시 확인, 수정할 수 있다.

4. 매일 메인라인 커밋<br>
메인라인: 시스템의 현재 상태를 의미하며 회사마다 어떤 브랜치를 메인라인으로 두는지는 조금씩 다르지만, 여기서는 master 브랜치를 메인라인으로 취급하도록 한다.
- 각자의 진행 상황을 추적하는 데 도움이 됩니다.<br>
- 짧은 주기로 커밋을 하므로, 충돌이 발생한 후 빠르게 충돌 상황을 감지할 수 있다.<br>
  - 해당 시점에는 충돌이 많이 발생하지 않아 문제를 쉽게 해결할 수 있다.<br>
  - 만약 통합의 빈도가 길어 충돌을 늦게 발견하게 된다면 문제를 해결하기 매우 어려울 수 있다.

5. 모든 팀원이 무슨 일이 일어나고 있는지 알아야 한다.<br>
- 지속적 통합은 커뮤니케이션에 관한 것이므로 모든 사람이 시스템 상태와 시스템에 적용된 변경사항을 쉽게 확인할 수 있어야한다.<br>.

6. 모든 커밋은 통합 서버의 메인라인에서 빌드 돼야 한다.<br>
- 개발자간 개발 환경에 차이가 있기 때문이다.

7. 빌드의 오류를 즉시 수정 할 수 있어야 합니다.<br>
- 빌드가 중단되는 것이 나쁜 것은 아니지만, 이러한 상황이 매번 항상 발생하는 경우 사람들이 커밋 전에 로컬에서 업데이트 및 빌드에 대해 충분히 주의하지 않고 있음을 시사합니다.<br>
- 지속적 통합 도구를 사용하면 빌드의 오류를 즉시 확인 할 수 있습니다.

8. 빌드가 빨리 되도록 유지해야한다.<br>
- 지속적 통합의 요점은 신속한 피드백을 제공하는 것이다.<br>
- 오랜 시간이 걸리는 빌드는 지속적 통합의 가장 큰 장애물이다.

9. 운영 환경과 동일한 환경에서 테스트가 진행돼야 한다.<br>
- 다른 환경에서 테스트하는 경우 환경의차이로 인해 테스트에서 발생하는 일이 프로덕션에서 발생하지 않을 위험이 있다.
- 누구나 최신 실행 파일을 쉽게 얻을 수 있어야 한다.

10. 배포 자동화가 이루어져야 한다.<br>
- 지속적 통합을 수행하려면 커밋 테스트를 실행하기 위한 환경과 2차 테스트를 실행하기 위한 하나 이상의 환경이 필요하다. <br>
이러한 환경 간에 실행 파일을 하루에 여러 번 이동하기 때문에 이 작업을 자동으로 수행하고 싶을 것이다. <br>
따라서 응용 프로그램을 모든 환경에 쉽게 배포할 수 있는 스크립트를 갖는 것이 중요하다.<br>

- 매일 프로덕션에 배포하지 않을 수도 있지만, 자동 배포는 프로세스 속도를 높이고 오류를 줄이는 데 도움이 됩니다. 또한 테스트 환경에 배포하는 데 사용하는 것과 동일한 기능을 사용하기 때문에 저렴한 옵션이 될 수 있습니다.


## 생각해 볼 점
지속적 통합이 있기 전에는 어떻게 릴리즈를 만들었을까요?

- 출시 기한을 정해놓고 소프트웨어를 완성하는 폭포수 모델
- 모든 수정사항을 한꺼번에 메인라인에 합쳐주는 커밋을 하고, 테스트한 다음 릴리즈를 한다.
- 따라서, 오류가 발생하는 것을 뒤늦게 알게되고 다시 오류를 수정하고 테스트를 하면서 릴리즈 간격이 갈수록 벌어지게 된다.
- 사용자가 항상 최신 버전을 다운받아 업데이트 해야함
  - 여전히 모바일 애플리케이션이 사용하는 전달 방식


지속적 통합을 통해 어떻게 버그를 일찍 발견할 수 있는걸까요?
- 변경점이 많이 수정되고 나서야 커밋을 하지 않고, 매일 메인라인에 커밋해주면서 지속적인 통합을 한다.
- 자동화된 통합과정으로 잦은 커밋을 할 수 있으며, 모든 진행상황을 쉽게 추적할 수 있게 된다.
- 브라우저에 접속하기만 해도, 새 버전을 즉시 사용할 수 있다
  - 사용자가 최신 버전 업데이트를 신경쓰지 않음
  - 원하는 만큼 잦은 릴리즈를 할 수 있음(빠른 문제 해결)
- 다양한 배포 방식을 적용하거나 A/B 테스트 가능


지속적 통합 과정에서 반드시 자동화가 이뤄져야 하는 부분은 어떤 부분인가요?
- Build > Test
- 빌드와 테스트를 자동화하여 지속적으로 품질 관리(Quality Control)를 적용하는 프로세스를 실행하는 것이다.
- 작은 단위의 작업, 빈번한 적용. 지속적인 통합은 모든 개발을 완료한 뒤에 품질 관리를 적용하는 고전적인 방법을 대체하는 방법으로서 소프트웨어의 질적 향상과 소프트웨어를 배포하는데 걸리는 시간을 줄이는데 초점이 맞추어져 있다.

지속적 통합을 도입함으로써 기존 개발 방식의 어떠한 문제를 해결해주었을까요?
- 언젠가는 저장소가 개발자들의 베이스라인과는 너무 많이 달라지게 되는 "통합의 지옥"이라 불리는 상황에 빠지게 된다. <br>
이 경우, 작업하는 시간보다 작업 내용을 통합하는데 소요되는 시간이 더 증가하게 되어, 최악의 경우 개발자들이 자신들의 변경 내용들을 취소하고 작업들을 완전히 처음부터 다시하는 것이 나을 수도 있다.

- 지속적인 통합은 "통합의 지옥"의 함정을 피하는 것을 내포하며 재작업에 들어가는 비용과 시간을 줄이는데 초점이 맞추어져 있다.

[reference](https://velog.io/@jm1225/Continuous-Intergration): https://velog.io/@jm1225/Continuous-Intergration

<br><br><br>

# 테스트
## TDD(테스트 주도 개발)
테스트 코드를 먼저 작성하는 개발 방법론은 테스트 주도 개발(Test-Driven Development, TDD)로 많이 불린다. 우리는 프로덕션 코드 보다 테스트 코드를 먼저 작성해야 하는데, 그 이유는 다음과 같다.

- 깔끔한 코드를 작성할 수 있다.
- 장기적으로 개발 비용을 절감할 수 있다.
- 개발이 끝나면 테스트 코드를 작성하는 것은 매우 까다롭다. <br>
실패 케이스면 더욱 그렇다.

TDD의 궁극적인 목표는 작동하는 깔끔한 코드를 작성하는 것이다.<br>
TDD의 개발 단계에는 리팩토링이 있는데, 이 리팩토링 과정을 거치면서 중복된 코드들은 제거되고, 복잡한 코드들은 깔끔하게 정리하게 된다.<br> 
또한 테스트를 처음 작성할 때에는 귀찮고 개발을 느리게 한다는 느낌을 받을 수 있지만, 장기적으로 보면 반드시 개발 비용을 아껴줄 것이다.

마지막으로는 현실적인 이야기인데, 프로덕션 코드를 먼저 작성하였다면 이후에 테스트 코드를 작성하는 과정은 너무 까다롭다. <br>
왜냐하면 테스트 코드는 성공 케이스 뿐만 아니라 실패 케이스까지 작성해야 하기 때문에 작성해야 할 테스트의 개수는 해당 함수에서 발생가능한 모든 경우들인 N이며, 이미 개발이 완료되었기에 끝났다는 심리적 요인 때문에 테스트를 작성하는 것이 꺼려지기 때문이다. <br>
그렇기 때문에 특별한 경우가 아니라면 테스트 코드를 먼저 작성하는 것이 좋다.

그리고 그 중에서도 실패 테스트부터 작성해야 한다.<br> 
즉, 순차적으로 실패하는 테스트를 먼저 작성하고, 오직 테스트가 실패할 경우에만 새로운 코드를 작성해야 한다. <br>
그리고 중복된 코드가 있으면 제거를 하는 것이다.

## 특징
- 테스트 코드를 먼저 작성하고, 그 테스트를 통과시키는 코드를 작성하는 방식
- 작은 단위의 기능별로 테스트를 작성하며, 이를 통해 전체 코드의 품질 향상을 도모함
- 작성한 테스트를 통해 리팩토링 과정에서 예기치 않은 버그를 발견할 수 있음
T- DD는 효율적인 코드 작성과 유지보수를 위해 필요한 테스트 코드를 작성할 수 있도록 함
- 테스트 주도 개발을 따르면 개발자는 코드 작성에 대한 집중도와 자신감을 높일 수 있음

### TDD(Test-Driven Development, 테스트 주도 개발) 방법 및 순서
TDD 개발 방법론의 프로그래밍 순서는 매우 단순하다.

1. 실패하는 작은 단위 테스트를 작성한다. 처음에는 컴파일조차 되지 않을 수 있다.
2. 빨리 테스트를 통과하기 위해 프로덕션 코드를 작성한다. <br>
이를 위해 정답이 아닌 가짜 구현 등을 작성할 수도 있다.
3. 그 다음의 테스트 코드를 작성한다. 실패 테스트가 없을 경우에만 성공 테스트를 작성한다.
4. 새로운 테스트를 통과하기 위해 프로덕션 코드를 추가 또는 수정한다.
5. 1~4단계를 반복하여 실패/성공의 모든 테스트 케이스를 작성한다.
6. 개발된 코드들에 대해 모든 중복을 제거하며 리팩토링한다.

위의 과정을 따라 개발을 진행하면 자연스럽게 프로덕션 코드보다 테스트 코드를 먼저 작성하게 될 것이다. <br>
물론 이론적으로만 해당 내용을 이해하기는 어렵다.<br> 
또한 이를 Spring과 같은 프레임워크에 적용하는 것은 다른 영역이고, 이러한 이유로 ATDD(Application TDD)라고 불린다. <br>
그러므로 Spring에서는 어떻게 TDD를 적용할 수 있는지 알아보도록 하자.


### TDD(Test-Driven Development, 테스트 주도 개발) 접근 방법
- 가짜로 구현하기: 최대한 빨리 테스트를 통과하기 위해 정답이 아닌 가짜 정답을 구현하는 방법
- 삼각측량법: 값이 다른 여러 테스트를 작성하고, 이를 일반화하여 정답을 구현하는 방법
- 명백하게 구현하기: 정답을 바로 구현하는 방법


#### 가짜로 구현하기
실패하는 테스트를 가장 빠르게 구현하는 방법은 아무 값이나 반환하도록 하는 것이다. <br>
그리고 테스트가 통과하면 단계적으로 상수를 변수를 사용하도록 변형한다. <br>
예를 들어 다음과 같은 곱하기 테스트를 작성하였다고 하자.

```
@Test
public void 곱하기테스트() {
    // given
    
    // when
    final int result = multiply(2, 3);
    
    // then
    assertThat(result).isEqualTo(6);
}
```

해당 테스트를 가장 빠르게 통과하는 방법은 6을 반환하는 것이다.
```
public int multiply(final int num1, final int num2) {
    return 6;
}
```

이렇게 변수를 사용하지 않고 상수를 반환하며, 답이 아닌 방법으로 가짜 구현하여 최대한 빨리 테스트를 통과하는 것이 가짜 구현 방법이다. <br>
가짜 구현으로 연습을 많이 해두면, 복잡한 코드일 경우에 단계를 잘게 쪼개서 TDD로 문제없이 개발하는 능력을 갖출 수 있다. <br>
가짜 구현으로 개발하면 다음과 같은 2가지 효과를 얻을 수 있다.
- 심리학적: 빨간 막대와 초록 막대 상태는 완전히 다르다. <br>
막대가 초록색이라면 어느 위치인지 알고 거기부터 리팩토링해 갈 수 있다.
- 범위 조절: 하나의 구체적인 예에서 일반화를 함으로써, 불필요한 고민으로 혼동되는 일을 예방할 수 있다.


#### 삼각 측량
삼각 측량은 테스트 주도로 추상화된 과정을 일반화하는 과정이다. <br>
삼각 측량 방법은 테스트 예시가 2개 이상일 때에만 추상화를 해야 한다. 
```
@Test
public void 곱하기테스트() {
    // given
    
    // when
    final int result1 = multiply(2, 3);
    final int result2 = multiply(4, 7);
    
    // then
    assertThat(result1).isEqualTo(6);
    assertThat(result2).isEqualTo(28);
}
```


#### 명백하게 구현하기
명백하게 구현하는 방법은 가짜 구현이나 삼각 측량 방법을 사용하지 않고 바로 정답을 구현하는 방법이다.

현재 사용하는 곱하기와 같은 문제는 쉬우므로 다음과 같이 바로 진짜 구현을 해도 괜찮다.
```
public int multiply(final int num1, final int num2) {
    return num1 * num2;
}
```

[reference](https://mangkyu.tistory.com/182): https://mangkyu.tistory.com/182

<br><br>

## 테스트의 종류
### 단위 테스트(Unit Test)
단위 테스트는 응용 프로그램에서 테스트 가능한 가장 작은 소프트웨어를 실행하여 예상대로 동작하는지 확인하는 테스트이다.

단위 테스트에서 테스트 대상 단위의 크기는 엄격하게 정해져 있지 않다. <br>
하지만, 일반적으로 클래스 또는 메소드 수준으로 정해진다. <br>
단위의 크기가 작을수록 단위의 복잡성이 낮아진다.<br> 
따라서, 단위 테스트를 활용하여 동작을 표현하기 더 쉬워진다. <br>
즉, 테스트 대상 단위의 크기를 작게 설정해서 단위 테스트를 최대한 간단하고 디버깅하기 쉽게 작성해야 한다.

소프트웨어를 개발할 때, 소프트웨어 내부 구조나 구현 방법을 고려하여 개발자 관점에서 테스트한다. 그러므로 단위 테스트는 소프트웨어 내부 코드에 관련한 지식을 반드시 알고 있어야 하는 화이트박스 테스트이다. 단위 테스트는 TDD와 함께 할 때 특히 더 강력해진다.


### 통합 테스트(Integration Test)
통합 테스트는 단위 테스트보다 더 큰 동작을 달성하기 위해 여러 모듈들을 모아 이들이 의도대로 협력하는지 확인하는 테스트이다.

통합 테스트는 단위 테스트와 달리 개발자가 변경할 수 없는 부분(ex. 외부 라이브러리)까지 묶어 검증할 때 사용한다. <br>
이는 DB에 접근하거나 전체 코드와 다양한 환경이 제대로 작동하는지 확인하는데 필요한 모든 작업을 수행할 수 있다. <br>
그러나, 통합 테스트가 응용 프로그램이 완전하게 작동하는 걸 무조건 증명하지는 않는다.

통합 테스트의 장점은 단위 테스트에서 발견하기 어려운 버그를 찾을 수 있다는 점이다. <br>
예를 들어, 통합 테스트에서는 환경 버그(ex. 싱글 코어 CPU에서는 잘 실행되나 쿼드 코어 CPU에서는 잘 실행되지 않음)이 발생할 수 있다.

한편, 통합 테스트의 단점은 단위 테스트보다 더 많은 코드를 테스트하기 때문에 신뢰성이 떨어질 수 있다는 점이다. <br>
또, 어디서 에러가 발생했는지 확인하기 쉽지 않아 유지보수하기 힘들다는 점도 있다.


### 인수 테스트(Acceptance Test)
인수 테스트는 사용자 스토리(시나리오)에 맞춰 수행하는 테스트이다.

앞선 두 테스트들과 달리 비즈니스 쪽에 초점을 둔다. <br>
프로젝트에 참여하는 사람들(ex. 기획자, 클라이언트 대표, 개발자 등)이 토의해서 시나리오를 만들고, 개발자는 이에 의거해서 코드를 작성한다. <br>
개발자가 직접 시나리오를 제작할 수도 있지만, 다른 의사소통집단으로부터 시나리오를 받아(인수) 개발한다는 의미를 가지고 있다.

인수 테스트는 애자일 개발 방법론에서 파생했다.<br> 
특히, 익스트림 프로그래밍(XP)에서 사용하는 용어이다. <br>
이는 시나리오가 정상적으로 동작하는지를 테스트하기 때문에 통합 테스트와는 분류가 다르다. <br>
시나리오에서 요구하는 것은 누가, 어떤 목적으로, 무엇을 하는가이다. <br>
개발을 하다 보면 이런 기능은 API를 통해 드러난다.<br> 
인수 테스트는 주로 이 API를 확인하는 방식으로 이뤄진다.

결국, 인수 테스트는 소프트웨어 인수를 목적으로 하는 테스트이다. <br>
소프트웨어를 인수하기 전에 명세한 요구사항(인수 조건)대로 잘 작동하는지 검증이 필요하다.

소프트웨어를 인수할 때, 소프트웨어 내부 구조나 구현 방법을 고려하기보다는 실제 사용자 관점에서 테스트하는 경우가 많다. <br>
따라서, 인수 테스트는 소프트웨어 내부 코드에 관심을 가지지 않는 블랙박스 테스트이다. <br>
실제 사용자 관점에서 테스트할 때 주로 E2E(End-to-End) 형식을 이용해서 확인한다.



## TIL
CI/CD를 첫주에 배울 당시에 팀원과 Github Action을 사용하여, CI/CD를 구축해보자 라는 생각을 하였었다.<br>
당시에는 처음 접하는 내용이다보니 생소하였는데, 오늘 스프린트를 진행하다보니, 알고보았더니 지금 내가 작성하고 있는 Github blog도 이미 Github Action을 통해서 CI/CD가 구축되어 있는 상태라는 것을 알게되었다. <br>
Github Action으로 간단하게 CI를 구축하면서, CI라는 개념에 대해 좀 더 자세하게 이해할 수 있었다. <br>

오늘 이론에서는 CI에서 사용되는
빌드와 테스트에 관한 내용을 주로 다룬다.<br>
빌드는 현재 우리는 node나 react를 많이 사용하고 있으므로, node가 우리가 현재 주로 사용하는 빌드 도구라고 할 수 있다.<br>

실제로 우리가 npm run build 같이 사용하던 명령이 빌드하는 명령어였었던 것이다.<br>
기존에 npm run test로 테스트 하던 부분은 단위테스트로 각 작은 부분에 대한 기능을 테스트하는 것들이였다고 되돌아 볼 수 있었다.