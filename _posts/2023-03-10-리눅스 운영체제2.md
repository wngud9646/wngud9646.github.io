---
title:  "리눅스 운영체제 2"
excerpt: "DevOps 부트캠프 Section 1 "

categories:
  - Blog
tags:
  - [Blog, DevOps]

toc: true
toc_sticky: true
 
date: 2023-03-10
last_modified_at: 2023-03-10
---
# 표준스트림?<br>
**표준 스트림은 ‘Standard Stream’** 의 약자로 컴퓨터 프로그램에서 ‘표준적으로’ 입력으로 받고 출력으로 보내는 데이터와 매체를 총칭하는 용어이다. <br>
 프로그램들은 많은 경우 정해진 어떤 ‘입력’을 받으며 많은 경우 정해진 어떤 형태의 ‘출력’을 내놓는다. <br>
 입출력이 전혀 없는 컴퓨터는 우리로써는 효용가치가 없을 것이다. <br>
 과거에는 하드웨어에 입출력이 얽혀있어 다루기 어렵고, 반복작업을 해야하는 일이였다.
 ![alt text](/images/redi.jpg)<br><br>

 표준 스트림에서 표준과 스트림이라는 단어를 나누어서 생각해보자. <br>
먼저 스트림(stream). 스트림은 프로그램을 드나드는 데이터를 바이트의 흐름으로(byte stream) 표현한 단어이다. <br>
유닉스에서는 과거의 입출력을 다루기 어려운 점을 장치를 추상화하여 각 장치를 파일처럼 다루는 방법으로 해결하였다. <br>
다양한 하드웨어 장치들을 파일을 읽고 쓰는 한 가지 작업으로써 다루게 된다. <br>
이 때, 이러한 파일들에서 잃히고 나가는 데이터들을 stream 이라고 정의했다. <br><br>

모든 프로그램이 입력과 출력을 필요로 하는데 어떤 프로그램에 있어 만약 대부분의 입력과 출력이 한 출처로부터만 발생한다면 사용자가 명시하지 않는 이상 기본적으로 사용할 입력과 출력을 프로그램 개발 시에 지정할 수 있으면 좋을 것이다. 이렇게 한 프로그램이 기본적으로 사용할 입출력 대상을 ‘표준 입출력’이라고 한다.<br>

‘쉘’은 키보드 입력을 표준 입력으로 하고 모니터 콘솔 출력을 표준 출력으로 한다. 또한 유닉스에서는 따로 명시되지 않는 한 표준 입출력 대상은 부모 프로세스로부터 상속 받는다. 쉘 상에서 ‘ls‘라는 프로그램을 실행하면 이 프로그램은 쉘 프로세스의 자식 프로세스로 실행이 되는데 이때 표준 출력을 상속 받아 쉘과 같은 콘솔에 결과를 반환하는 것이다. <br>

표준 입출력은 표준 입력과 표준 출력으로 나뉘고 표준 출력은 표준 출력와 표준 에러로 나뉜다. 각 프로세스는 초기화될 때 세 가지 스트림이 설정되는데 **표준 출력, 표준 입력, 표준 에러** 이다. <br><br>

## 표준 입력
표준 입력(Standard input)은 프로그램에 입력되는 데이터의 표준적인 출처(장비나 파일)를 일컬으며 stdin 으로 줄여 표현한다. <br>
유닉스 쉘에서는 표준 입력이 키보드로 설정되어 있다.

리눅스에서 표준 입력은 file descriptor(파일을 고유하게 구별하는 식별자) 가 0으로 설정되어 있다. <br><br>

## 표준 출력
표준 출력(Standard output)은 프로그램에서 출력되는 데이터의 표준적인 방향(장비나 파일)을 일컬으며 크게 표준 출력(stdout)과 표준 에러(stderr)로 구분할 수 있다. 유닉스 쉘에서는 표준 출력, 표준 에러 모두 콘솔로 설정되어 있다. <br>

표준 출력은 정상적인 출력이 반환되는 방향을 말하고, 표준 에러는 프로그램의 비정상 종료 시에 반환되는 방향이다. <br>
프로그램이 정상적으로 종료하면 사용자가 바라던 형태의 출력 결과가 나올 것이다. <br>
하지만 실행 시에 어떠한 장애를 만나 비정상적으로 종료하면 보통 에러 메시지를 반환하게 된다. <br>
리눅스에서 표준 출력은 file descriptor가 1로 설정되어 있다. <br>
표준 에러의 file descriptor는 2로 설정되어 있다. <br><br>
[출처](https://shoark7.github.io/programming/knowledge/what-is-standard-stream) : 
https://shoark7.github.io/programming/knowledge/what-is-standard-stream

### 파일 디스크립터(File Disciptor)
리눅스의 모든 파일을 관리하는 방식<br>

명령어 실행 ( 컴퓨터에게 작업을 요청 -> 프로세스 생성 ) <br>

- 실제 프로그램을 실행시키는 작업
- 이러한 프로그램은 파일로 존재
- 파일을 실행 시키기위해서는 먼저 파일을 열어야 한다.
- 파일이 열리면 커널이 해당 프로세스가 동작하는데 필요한장치나 파일을 번호를 붙이며 관리하고, 이러한 번호를 파일 디스크립터 테이블에 저장
- 자주 사용하는 장치들은 미리 번호가 예약되어 있어서 아래와 같이 표현된다.<br><br>

### 파일 디스크립터 테이블
|장치 |번호|설명|
|------|---|---|
|표준 입력장치 (키보드)|0 ( stdin )| 명령어의 표준 입력|
|표준 출력장치 (모니터)|1 ( stdout )|명령어의 표준 출력|
|표준 에러장치 (모니터)|2 ( stderr )|명령어의 표준 오류|


## 리다이렉션 (Redirection)
기본적으로 명령어의 결과는 표준 출력 방식인 모니터에 출력된다. <br>
하지만 리다이렉션을 이용하면 명령의 출력을 변경할 수 있다.<br>
리다이렉션을 이용하여 파일에 기록할 수 있다.<br><br>
기존 파일의 내용을 삭제하고 새로 결과를 저장할 때는 >를,<br>
기존 파일의 내용 뒤에 결과를 추가할 때는 >>를 사용한다.<br>

'< / <<' : 입력 방향 재지정<br>
'> / >>' : 출력 방향 재지정<br>
'>' : 덮어씀<br>
'>>' : 추가됨<br>

![alt text](/images/redi2.jpg)<br><br>

1. 입력 리다이렉션<br>
#[명령어] < [파일]<br>
명령어의 입력(0)으로 파일을 사용
 
- ex) #cat < /etc/resolv.conf      == cat /etc/resolv.conf와 동일
- ex) #nl < /etc/resolv.conf        == nl /etc/resolv.conf와 동일
- ex) #head -3 < /etc/passwd    == head -3 < /etc/passwd와 동일<br><br>


2. **출력 리다이렉션**<br>
#[명령어] > [파일]<br>
화면 (표준 출력장치)에 출력되는 결과를 파일의 내용으로 사용하는 방법 <br>

- #ls -l > result<br>
-> ">기호를 통해 result라는 파일로 리다이렉션하라" 라는 뜻이다. <br>
결과적으로 ls -l 명령의 출력값이 result 파일에 저장된다.<br><br>


3. 추가 리다이렉션<br>
#[명령어] >> [파일]<br>
표준출력장치(1)에 결과를 파일에 추가


4. 오류 리다이렉션<br>
#[명령어] > [파일]<br>
오류 출력은<br>
예를들면, Root가 아닌 일반 사용자로 find 명령어를 사용할 때에는 일반 사용자가 접근 할 수 있는 폴더에서만 파일을 찾게된다.<br>
검색 과정 중 Root만이 들어갈 수 있는 폴더에 접촉할 경우 오류 메세지를 내보내게 된다.<br>
그럴 경우 이것을 다른 파일로 돌려버리면 오류를 제외한 검색 결과만을 볼 수 있게된다.<br><br>

### 파이프
기호 - | (shift + \)<br>
파이프란?<br>
앞 명령어의 결과를 뒤에 나오는 명령어의 입력으로 처리하기 위해 사용하는 방법이다.
<br>
즉, 파이프를 이용하면 명령어를 조합해서 쓸 수 있으며, 서로 다른 프로세스간 작동하는 방식이다.

[출처](https://neul-carpediem.tistory.com/70) : 
https://neul-carpediem.tistory.com/70
<br><br>

### 출력관련 명령어
### cat<br>
cat 명령어는 텍스트로 된 파일일 경우 그 내용을 정상적으로 출력하지만 바이너리 파일일 경우에는 출력은 하지만 알아볼 수 없다. 그리고 2개 이상의 파일이름이 지정되면 모든 파일이 연결되어 보여진다.<br>

사용법 : cat [옵션] 파일명

test 파일을 열어봄
> cat test 

각 행에 번호를 붙여서 출력
> cat -b test 

빈 행에도 번호를 붙임
> cat -n test

연속되는 2개이상의 빈 행을 한행으로 출력
> cat -s test 

<br>

### more <br>
more 명령어는 특정파일의 내용을 확인하는 그 페이지에서 바로 vi 로 파일을 열어서 편집을 할 수도 있으며 텍스트 파일의 내용을 한 페이지씩 차례대로 확인할 수 있다.

사용법 : more 파일명

많은 양의 파일리스트를 확인할때 파이프를 이용해 연결
> more test

특정 파일의 내용을 확인하고 있는 상태에서 사용할 수 있는 키
> ls -l /etc | more

- h : more 명령어상태에서 사용할 수 있는 키 도움말 확인
- Space Bar : 한 화면씩 뒤로 이동하기 (f와 동일)
- Enter : 현재행에서 한 행씩 뒤로 이동하기
- -q : more 명령어 종료하기
- -f : 한 페이지씩 뒤로 이동하기(Space Bar 와 동일)
- -b : 한 페이지씩 앞으로 이동하기
- = : 현재 위치의 행번호 표시하기
- /문자열 : 지정한 문자열을 검색하기
- -n : /문자열로 검색한 문자열을 차례대로 계속해서 찾기
- !쉘명령어 : more 명령어상태에서 쉘명령어를 실행하기
- -v : more 명령어로 열려있는 파일의 현재위치에서 vi를 실행하기

<br>

### less
less는 more와 매우 유사하다.

사용법 : less 파일명

>less test <br>
ls -l | less
less 내부명령키

- Space Bar 또는 f : 한 화면 뒤로 이동
- b : 한 화면 앞으로 이동
- Enter : 한 행씩 뒤로 이동
- 숫자+n : 원하는 페이지만큼 뒤로 이동, 이후부터는 n만 눌러도 숫자페이지만큼 이동
- q : less 수행종료 

<br>

### head 
head는 파일의 앞부분부터 확인하는 명령어이다.

사용법 : head 파일명

기본적으로 행의 앞부분 부터 10 행까지만 출력
> head test 

20행까지 출력
> head -n 20 test 

200 byte 까지의 내용을 출력
> head -c 200 test 

<br>

### tail
tail
tail은 특정파일에 계속 추가되는 모든 내용을 모니터링 할 수 있어 실무에서 유용하게 사용되는 명령어이다.

/var/log/ 디렉토리에 존재하는 많은 시스템로그파일들의 로그파일들에 저장되는 내용들을 실시간으로 계속 모니터링하기 위한 용도로 자주 사용된다.

사용법 : tail 파일명

기본적으로 파일에서 마지막 부분의 10개행을 화면에 출력
> tail test 

마지막 부분의 20개행까지 출력
>tail -n 20 test

마지막에서 200byte 까지를 출력
> tail -c 200 test  

로그파일을 실시간 모니터링, 종료는 Ctrl-c
> tail -f /var/log/messages


## Action action
### wc
wc 명령어는 파일 내의 줄, 단어, 글자 수를 세는데에 사용된다.

> wc myfile.txt

줄의 수를 알고 싶다면 옵션 -ㅣ을 사용
> wc -l myfile.txt

단어의 수를 알고 싶다면 옵션 -w를 사용
> wc -w myfile.txt

글자의 수를 알고 싶다면 옵션 -c를 사용
> wc -c myfile.txt 

<br>

### cut
cut 명령어는 file 이나 표준 입력에서 받은 문자열을 잘라내서 새로운 문자열을 만드는 명령어이다.
예시로써, 파일의 1열부터 3열까지 제거한다면,  
> cut -f 1,3 myfile.txt

- -b, --bytes	바이트를 기준으로 잘라냅니다.	
- -c, --characters	문자열을 기준으로 잘라냅니다.	
- -d, --delimiter	지정한 문자를 구분자로 사용합니다. (기본 TAB)	
- -f, --fields	필드를 기준으로 잘라냅니다.	
- -z, --zero-terminated	라인의 구분자를 개행문자가 아닌 NUL 을 사용합니다.
<br>

### awk
AWK는 유닉스에서 개발된 스크립트 언어로 텍스트가 저장되어 있는 파일을 원하는 대로 필터링하거나 추가해주거나 기타 가공을 통해서 나온 결과를 행과 열로 출력해주는 프로그램. (테이블을 다룬다고 이해함)<br>

### join
두 파일에서 공통의 필드가 있는 행들을 병합한다. join이 정상 동작 하려면 입력 파일들의 행들을 미리 정렬해 두어야 한다.
- -j <필드> : 지정된 필드 번호를 이용해서 병합한다. 필드 번호는 1부터 시작
- -t <문자> : 지정된 문자를 필드 구분 문자로 사용
- --header : 각 파일의 첫 행을 헤더 행으로 사용
<br>

### paste
paste는 여러 텍스트 파일을 수평적으로 join, merge 하는 유닉스 커맨드 라인 유틸리티이다.
- -s 옵션은 수직으로 되어있는 값을 읽어 수평으로 출력
- -d 옵션은 구분자를 지정하여 출력
- -s -d 옵션으로 구분자로 탭(\t)과 개행(\n) 사용하여 출력


### SED
ed명령어와 grep명령어 기능의 일부를 합친 것이 sed(stream editor)명령어이다. <br> sed명령어도 grep명령어와 같은 필터이지만 이 명령어는 파일을 수정할 수 있게 하는 반면 ed처럼 대화식처리는 불가능하다.<br>
sed명령어는 1개 라인씩 입력 라인을 읽어들여 표준출력으로 출력한다.<br>

sed명령어가 ed보다 좋은 점은 라인들을 하나씩 읽고, 수정하고, 출력하기 때문에 기억장치 안의 버퍼를 사용하지 않는다는 것이다. <br>
버퍼를 사용하지 않으면 파일의 크기에 제한 없이 작업을 할 수 있다.<br>
ed와 같이 버퍼를 사용하는 경우는 버퍼의 크기보다 큰 파일은 처리할 수 없으며 대개 버퍼의 크기는 1MB정도이다. <br>
따라서 sed는 아주 큰 파일을 처리할 때 주로 사용된다. <br><br>

### uniq
uniq 는 입력 내용에서 중복된 항목을 제거하는 커맨드 라인 유틸리티이다. <br>
보통 sort 명령어로 정렬을 한 결과를 파이프로 uniq 에 전달해서 중복 내용을 제거한다. <br>
uniq 는 기본적으로 대소문자를 구분하므로 'abc' 와 'AbC' 를 다르게 인식한다. 

- -u 옵션을 사용하면 중복되지 않는 라인만 표시한다. 즉 중복된 line 인 bat 는 표시하지 않는다. 
- -d 옵션을 사용하면 -u 와는 반대로 중복되는 라인만 표시하며 아래 예제는 중복되는 line인 bat 만 표시한다.
- -c 옵션을 사용하면 각 라인별 중복 횟수를 계산해서 표시한다. bat 만 중복되므로 2 가 표시되고 나머지는 다 1이 표시된다. <br>
-c 는 -d 나 -u 옵션과도 같이 사용할 수 있다.
- 대소문자를 무시하는 옵션인 -i, --ignore-case 를 사용하면 'abc' 와 'ABC', 'aBc' 를 모두 같게 처리합니다.<br>

### grep
리눅스에서 grep 명령어는 특정 파일에서 지정한 문자열이나 정규표현식을 포함한 행을 출력해주는 명령어이다. 특히 tail이나 ls 등 다양한 명령어와 조합하여 응용되는 경우가 많아서 이 grep명령어는 리눅스에서 능숙하게 사용할 줄 알아야 하는 기본 명령어이다.

grep 사용법
> grep [옵션][패턴][파일명]

<br>

### 문자열로 찾기<br>
특정 파일에서 'error' 문자열 찾기
> grep 'error' 파일명

여러개의 파일에서 'error' 문자열 찾기
> grep 'error' 파일명1 파일명2

현재 디렉토리내에 있는 모든 파일에서 'error' 문자열 찾기
> grep 'error' *

특정 확장자를 가진 모든 파일에서 'error' 문자열 찾기
> grep 'error' *.log

<br>

### 정규표현식으로 찾기
특정 파일에서 문자열이 포함된 행을 찾는다.
> grep '^[ab]' 파일명 

특정 파일에서 a로 시작하는 모든 단어를 찾는다.
> grep 'a*' 파일명 

특정 파일에서 a로 시작하고 z로 끝나는 5자리 단어를 찾는다.
> grep 'a...z' 파일명 

특정 파일에서 a,b,c로 시작하는 단어를 모두 찾는다.
> grep [a-c] 파일명

특정 파일에서 apple 또는 Apple로 시작하는 단어를 모두 찾는다.
> grep [aA]pple 파일명 

특정 파일에서 a나 b로 시작되는 모든 행을 찾는다.
> grep '^[ab]' 파일명 

특정 파일에서 apple로 시작되고 0나 9의 숫자로 끝나로 시작되는 모든 행을 찾는다.
> grep 'apple'[0-9] 파일명

<br>
자주 사용하는 옵션

- -c : 일치하는 행의 수를 출력한다.
- -i : 대소문자를 구별하지 않는다.
- -v : 일치하지 않는 행만 출력한다.
- -n : 포함된 행의 번호를 함께 출력한다.
- -l : 패턴이 포함된 파일의 이름을 출력한다.
- -w : 단어와 일치하는 행만 출력한다.
- -x : 라인과 일치하는 행만 출력한다.
- -r : 하위 디렉토리를 포함한 모든 파일에서 검색한다.
- -m 숫자 : 최대로 표시될 수 있는 결과를 제한한다.
- -E : 찾을 패턴을 정규 표현식으로 찾는다.
- -F : 찾을 패턴을 문자열로 찾는다.


<br> 

# 시스템 관리자가 하는 일
### 1. 접근 제어 ###
### 2. 업무 자동화 ###
### 3. 재난 대비 ###
### 4. 애플리케이션 배포 및 관리 ###
### 5. 모니터링 ###
### 6. 기타 ###